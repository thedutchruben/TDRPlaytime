This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
main/java/nl/thedutchruben/playtime/core/ConfigFiles.java
main/java/nl/thedutchruben/playtime/core/DependencyLoader.java
main/java/nl/thedutchruben/playtime/core/events/milestone/MilestoneCreateEvent.java
main/java/nl/thedutchruben/playtime/core/events/milestone/MilestoneDeleteEvent.java
main/java/nl/thedutchruben/playtime/core/events/milestone/MilestoneEvent.java
main/java/nl/thedutchruben/playtime/core/events/milestone/MilestoneReceiveEvent.java
main/java/nl/thedutchruben/playtime/core/events/milestone/MilestoneUpdateEvent.java
main/java/nl/thedutchruben/playtime/core/events/player/AsyncPlaytimePlayerUpdatePlaytimeEvent.java
main/java/nl/thedutchruben/playtime/core/events/player/PlaytimePlayerEvent.java
main/java/nl/thedutchruben/playtime/core/events/player/PlaytimePlayerLoadedEvent.java
main/java/nl/thedutchruben/playtime/core/events/player/PlaytimePlayerSaveEvent.java
main/java/nl/thedutchruben/playtime/core/events/player/PlaytimePlayerUnLoadedEvent.java
main/java/nl/thedutchruben/playtime/core/events/repeatingmilestone/RepeatingMilestoneCreateEvent.java
main/java/nl/thedutchruben/playtime/core/events/repeatingmilestone/RepeatingMilestoneDeleteEvent.java
main/java/nl/thedutchruben/playtime/core/events/repeatingmilestone/RepeatingMilestoneEvent.java
main/java/nl/thedutchruben/playtime/core/events/repeatingmilestone/RepeatingMilestoneReceiveEvent.java
main/java/nl/thedutchruben/playtime/core/events/repeatingmilestone/RepeatingMilestoneUpdateEvent.java
main/java/nl/thedutchruben/playtime/core/objects/Milestone.java
main/java/nl/thedutchruben/playtime/core/objects/MilestoneTest.java
main/java/nl/thedutchruben/playtime/core/objects/PlaytimeUser.java
main/java/nl/thedutchruben/playtime/core/objects/PlaytimeUserTest.java
main/java/nl/thedutchruben/playtime/core/objects/RepeatingMilestone.java
main/java/nl/thedutchruben/playtime/core/Settings.java
main/java/nl/thedutchruben/playtime/core/storage/exceptions/StorageTypeNotFoundException.java
main/java/nl/thedutchruben/playtime/core/storage/SqlStatements.java
main/java/nl/thedutchruben/playtime/core/storage/Storage.java
main/java/nl/thedutchruben/playtime/core/storage/types/Mongodb.java
main/java/nl/thedutchruben/playtime/core/storage/types/Mysql.java
main/java/nl/thedutchruben/playtime/core/storage/types/SqlLite.java
main/java/nl/thedutchruben/playtime/core/storage/types/SqlLiteTest.java
main/java/nl/thedutchruben/playtime/core/storage/types/Yaml.java
main/java/nl/thedutchruben/playtime/core/translations/Messages.java
main/java/nl/thedutchruben/playtime/extentions/BStatsExtension.java
main/java/nl/thedutchruben/playtime/extentions/PlaceholderAPIExtension.java
main/java/nl/thedutchruben/playtime/modules/milestones/commands/MileStoneCommand.java
main/java/nl/thedutchruben/playtime/modules/milestones/commands/RepeatingMilestoneCommand.java
main/java/nl/thedutchruben/playtime/modules/milestones/listeners/UpdatePlaytimeListener.java
main/java/nl/thedutchruben/playtime/modules/player/commands/PlayTimeCommand.java
main/java/nl/thedutchruben/playtime/modules/player/listeners/PlayerJoinListener.java
main/java/nl/thedutchruben/playtime/modules/player/listeners/PlayerQuitListener.java
main/java/nl/thedutchruben/playtime/modules/player/runnables/SavePlayTimeRunnable.java
main/java/nl/thedutchruben/playtime/modules/player/runnables/UpdatePlayTimeRunnable.java
main/java/nl/thedutchruben/playtime/modules/playtime_history/commands/PlaytimeHistoryCommand.java
main/java/nl/thedutchruben/playtime/modules/playtime_history/listeners/PlayTimePlayerLoadedListener.java
main/java/nl/thedutchruben/playtime/modules/playtime_history/runnables/MidnightSaveJoinsRunnable.java
main/java/nl/thedutchruben/playtime/modules/playtime_history/runnables/MidnightSaveQuitsRunnable.java
main/java/nl/thedutchruben/playtime/Playtime.java
main/java/nl/thedutchruben/playtime/PlayTimePlugin.java
main/java/nl/thedutchruben/playtime/PlayTimePluginTest.java
main/java/nl/thedutchruben/playtime/utils/Replacement.java
main/resources/plugin.yml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="main/java/nl/thedutchruben/playtime/core/ConfigFiles.java">
package nl.thedutchruben.playtime.core;

import lombok.Getter;

@Getter
public enum ConfigFiles {
    CONFIG("config.yml"),
    STORAGE("storage.yml");

    private final String fileName;

    ConfigFiles(String fileName) {
        this.fileName = fileName;
    }

}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/DependencyLoader.java">
package nl.thedutchruben.playtime.core;

import lombok.Getter;
import net.byteflux.libby.BukkitLibraryManager;
import net.byteflux.libby.Library;
import net.byteflux.libby.logging.LogLevel;
import org.bukkit.plugin.Plugin;

import java.util.ArrayList;
import java.util.List;

public class DependencyLoader {

    public static void load(Plugin plugin) {
        plugin.getLogger().info("Loading dependencies");

        BukkitLibraryManager libraryManager = new BukkitLibraryManager(plugin);
        // setup repo's
        libraryManager.addMavenCentral();
        libraryManager.addJitPack();
        libraryManager.addRepository("https://maven.thedutchservers.com/releases");
        libraryManager.setLogLevel(LogLevel.INFO);

        //build array with all the dependencies as liberies
        List<Library> libraries = new ArrayList<>();
        for (Dependency dependency : Dependency.values()) {
            Library.Builder builder = Library.builder()
                    .groupId(dependency.getGroupId()) // "{}" is replaced with ".", useful to avoid unwanted changes made by maven-shade-plugin
                    .artifactId(dependency.getArtifactID())
                    .version(dependency.getVersion());

            if (dependency.getRelocation() != null) {
                builder.relocate(dependency.getGroupId(), dependency.getRelocation());
            }
            libraries.add(builder.build());
        }
        // Load all the dependencies
        for (Library library : libraries) {
            libraryManager.loadLibrary(library);
        }
    }

    @Getter
    private enum Dependency {
        BSON("org{}mongodb", "bson", "5.2.1", null),
        MONGODB("org{}mongodb", "mongodb-driver-sync", "5.2.1", null),
        MONGODB_CORE("org{}mongodb", "mongodb-driver-core", "5.2.1", null),
        MCCORE("nl{}thedutchruben", "mccore", "1.4.9", null),
        BSTATS("org{}bstats", "bstats-bukkit", "3.0.2", "nl{}thedutchruben{}playtime{}bstats"),
        BSTATS_BASE("org{}bstats", "bstats-base", "3.0.2", "nl{}thedutchruben{}playtime{}bstats"),
        HIKARI_CP("com{}zaxxer", "HikariCP", "6.0.0", null);

        public final String version;
        public final String relocation;
        private final String groupId;
        private final String artifactID;

        Dependency(String groupId, String artifactID, String version, String relocation) {
            this.groupId = groupId;
            this.artifactID = artifactID;
            this.version = version;
            this.relocation = relocation;
        }
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/milestone/MilestoneCreateEvent.java">
package nl.thedutchruben.playtime.core.events.milestone;

import nl.thedutchruben.playtime.core.objects.Milestone;

/**
 * Event that is called when a milestone is created
 */
public class MilestoneCreateEvent extends MilestoneEvent {

    /**
     * Create a new MilestoneCreateEvent
     * @param milestone The milestone that is created
     */
    public MilestoneCreateEvent(Milestone milestone) {
        super(milestone);
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/milestone/MilestoneDeleteEvent.java">
package nl.thedutchruben.playtime.core.events.milestone;

import nl.thedutchruben.playtime.core.objects.Milestone;

/**
 * Event that is called when a milestone is deleted
 */
public class MilestoneDeleteEvent extends MilestoneEvent {

    /**
     * Create a new MilestoneDeleteEvent
     * @param milestone The milestone that is deleted
     */
    public MilestoneDeleteEvent(Milestone milestone) {
        super(milestone);
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/milestone/MilestoneEvent.java">
package nl.thedutchruben.playtime.core.events.milestone;

import lombok.Getter;
import nl.thedutchruben.playtime.core.objects.Milestone;
import org.bukkit.event.Event;
import org.bukkit.event.HandlerList;

/**
 * Base for the milestone events
 */
public abstract class MilestoneEvent extends Event {
    private static final HandlerList handlers = new HandlerList();
    @Getter
    private Milestone milestone;

    public MilestoneEvent(Milestone milestone) {
        this.milestone = milestone;
    }

    public static HandlerList getHandlerList() {
        return handlers;
    }

    @Override
    public HandlerList getHandlers() {
        return handlers;
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/milestone/MilestoneReceiveEvent.java">
package nl.thedutchruben.playtime.core.events.milestone;

import nl.thedutchruben.playtime.core.objects.Milestone;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;

/**
 * Event that is called when a milestone is received
 */
public class MilestoneReceiveEvent extends MilestoneEvent {
    private final PlaytimeUser playtimeUser;

    /**
     * Create a new MilestoneReceiveEvent
     * @param milestone The milestone that is received
     * @param playtimeUser The user that received the milestone
     */
    public MilestoneReceiveEvent(Milestone milestone, PlaytimeUser playtimeUser) {
        super(milestone);

        this.playtimeUser = playtimeUser;
    }

    /**
     * Get the user that received the milestone
     * @see PlaytimeUser
     * @return The user that received the milestone
     */
    public PlaytimeUser getPlaytimeUser() {
        return playtimeUser;
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/milestone/MilestoneUpdateEvent.java">
package nl.thedutchruben.playtime.core.events.milestone;

import nl.thedutchruben.playtime.core.objects.Milestone;

/**
 * Event that is called when a milestone is updated
 */
public class MilestoneUpdateEvent extends MilestoneEvent {

    /**
     * Create a new MilestoneUpdateEvent
     * @param milestone The milestone that is updated
     */
    public MilestoneUpdateEvent(Milestone milestone) {
        super(milestone);
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/player/AsyncPlaytimePlayerUpdatePlaytimeEvent.java">
package nl.thedutchruben.playtime.core.events.player;

import lombok.Getter;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;

/**
 * This events get's called every time that the playtime gets updated (every 15 seconds)
 */
@Getter
public class AsyncPlaytimePlayerUpdatePlaytimeEvent extends PlaytimePlayerEvent {
    private final float oldPlaytime;
    private final float newPlaytime;

    /**
     * Create a new PlaytimePlayerUpdatePlaytimeEvent
     *
     * @param user        the user that is updated
     * @param async       if the event is async
     * @param oldPlaytime the old playtime
     * @param newPlaytime the new playtime
     */
    public AsyncPlaytimePlayerUpdatePlaytimeEvent(PlaytimeUser user, boolean async, float oldPlaytime, float newPlaytime) {
        super(user, async);
        this.oldPlaytime = oldPlaytime;
        this.newPlaytime = newPlaytime;
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/player/PlaytimePlayerEvent.java">
package nl.thedutchruben.playtime.core.events.player;

import lombok.Getter;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import org.bukkit.event.Event;
import org.bukkit.event.HandlerList;

/**
 * This is the base class for all the player events
 */
@Getter
public abstract class PlaytimePlayerEvent extends Event {
    private static final HandlerList handlers = new HandlerList();
    private PlaytimeUser user;

    /**
     * Create a new PlaytimePlayerEvent
     *
     * @param user  The user
     * @param async If the event is async
     */
    public PlaytimePlayerEvent(PlaytimeUser user, boolean async) {
        super(async);
        this.user = user;
    }

    public static HandlerList getHandlerList() {
        return handlers;
    }

    @Override
    public HandlerList getHandlers() {
        return handlers;
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/player/PlaytimePlayerLoadedEvent.java">
package nl.thedutchruben.playtime.core.events.player;

import nl.thedutchruben.playtime.core.objects.PlaytimeUser;

/**
 * Event that is called when a player is loaded
 */
public class PlaytimePlayerLoadedEvent extends PlaytimePlayerEvent {

    /**
     * Create a new PlaytimePlayerLoadedEvent
     * @param user The user that is loaded
     * @param async If the event is async
     */
    public PlaytimePlayerLoadedEvent(PlaytimeUser user, boolean async) {
        super(user, async);
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/player/PlaytimePlayerSaveEvent.java">
package nl.thedutchruben.playtime.core.events.player;

import nl.thedutchruben.playtime.core.objects.PlaytimeUser;

/**
 * This event is called when a player is saved
 */
public class PlaytimePlayerSaveEvent extends PlaytimePlayerEvent {

    /**
     * Create a new PlaytimePlayerSaveEvent
     *
     * @param user  the user that is saved
     * @param async if the event is async
     */
    public PlaytimePlayerSaveEvent(PlaytimeUser user, boolean async) {
        super(user, async);
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/player/PlaytimePlayerUnLoadedEvent.java">
package nl.thedutchruben.playtime.core.events.player;

import nl.thedutchruben.playtime.core.objects.PlaytimeUser;

/**
 * This event is called when a player is unloaded
 */
public class PlaytimePlayerUnLoadedEvent extends PlaytimePlayerEvent {
    /**
     * Create a new PlaytimePlayerUnLoadedEvent
     *
     * @param user  the user that is unloaded
     * @param async if the event is async
     */
    public PlaytimePlayerUnLoadedEvent(PlaytimeUser user, boolean async) {
        super(user, async);
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/repeatingmilestone/RepeatingMilestoneCreateEvent.java">
package nl.thedutchruben.playtime.core.events.repeatingmilestone;

import nl.thedutchruben.playtime.core.objects.RepeatingMilestone;

/**
 * Event that is called when a RepeatingMilestone is created
 */
public class RepeatingMilestoneCreateEvent extends RepeatingMilestoneEvent {

    /**
     * Create a new RepeatingMilestoneCreateEvent
     *
     * @param repeatingMilestone The RepeatingMilestone that is created
     */
    public RepeatingMilestoneCreateEvent(RepeatingMilestone repeatingMilestone) {
        super(repeatingMilestone);
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/repeatingmilestone/RepeatingMilestoneDeleteEvent.java">
package nl.thedutchruben.playtime.core.events.repeatingmilestone;

import nl.thedutchruben.playtime.core.objects.RepeatingMilestone;

/**
 * Event that is called when a RepeatingMilestone is deleted
 */
public class RepeatingMilestoneDeleteEvent extends RepeatingMilestoneEvent {

    /**
     * Create a new RepeatingMilestoneDeleteEvent
     *
     * @param repeatingMilestone The RepeatingMilestone that is deleted
     */
    public RepeatingMilestoneDeleteEvent(RepeatingMilestone repeatingMilestone) {
        super(repeatingMilestone);
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/repeatingmilestone/RepeatingMilestoneEvent.java">
package nl.thedutchruben.playtime.core.events.repeatingmilestone;

import lombok.Getter;
import nl.thedutchruben.playtime.core.objects.RepeatingMilestone;
import org.bukkit.event.Event;
import org.bukkit.event.HandlerList;

/**
 * Base for the repeatingMilestone events
 */
public abstract class RepeatingMilestoneEvent extends Event {
    private static final HandlerList handlers = new HandlerList();
    @Getter
    private RepeatingMilestone repeatingMilestone;

    /**
     * Create a new RepeatingMilestoneEvent
     *
     * @param repeatingMilestone The RepeatingMilestone
     */
    public RepeatingMilestoneEvent(RepeatingMilestone repeatingMilestone) {
        this.repeatingMilestone = repeatingMilestone;
    }

    public static HandlerList getHandlerList() {
        return handlers;
    }

    @Override
    public HandlerList getHandlers() {
        return handlers;
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/repeatingmilestone/RepeatingMilestoneReceiveEvent.java">
package nl.thedutchruben.playtime.core.events.repeatingmilestone;

import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import nl.thedutchruben.playtime.core.objects.RepeatingMilestone;

/**
 * Event that is called when a RepeatingMilestone is received
 */
public class RepeatingMilestoneReceiveEvent extends RepeatingMilestoneEvent {

    private final PlaytimeUser playtimeUser;

    /**
     * Create a new RepeatingMilestoneReceiveEvent
     * @param repeatingMilestone The RepeatingMilestone that is received
     * @param playtimeUser The user that received the RepeatingMilestone
     */
    public RepeatingMilestoneReceiveEvent(RepeatingMilestone repeatingMilestone, PlaytimeUser playtimeUser) {
        super(repeatingMilestone);

        this.playtimeUser = playtimeUser;
    }

    public PlaytimeUser getPlaytimeUser() {
        return playtimeUser;
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/events/repeatingmilestone/RepeatingMilestoneUpdateEvent.java">
package nl.thedutchruben.playtime.core.events.repeatingmilestone;

import nl.thedutchruben.playtime.core.objects.RepeatingMilestone;

/**
 * Event that is called when a RepeatingMilestone is updated
 */
public class RepeatingMilestoneUpdateEvent extends RepeatingMilestoneEvent {

    /**
     * Create a new RepeatingMilestoneUpdateEvent
     * @param repeatingMilestone The RepeatingMilestone that is updated
     */
    public RepeatingMilestoneUpdateEvent(RepeatingMilestone repeatingMilestone) {
        super(repeatingMilestone);
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/objects/Milestone.java">
package nl.thedutchruben.playtime.core.objects;

import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import lombok.Setter;
import nl.thedutchruben.mccore.utils.firework.FireworkUtil;
import nl.thedutchruben.mccore.utils.message.MessageUtil;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.events.milestone.MilestoneReceiveEvent;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class Milestone {
    private transient List<ItemStack> _itemStackObjects;

    /**
     * The name of the milestone
     * -- GETTER --
     * get the name of the milestone
     * -- SETTER --
     * set the name of the milestone
     */
    @Setter
    @Getter
    @SerializedName("_id")
    private String milestoneName;

    /**
     * The time the player has to be online to get the milestone
     * -- GETTER --
     * get the time the player has to be online to get the milestone
     * -- SETTER --
     * set the time the player has to be online to get the milestone
     */
    @Setter
    @Getter
    @SerializedName("online_time")
    private long onlineTime;

    /**
     * The list of items to give the player.
     */
    @SerializedName("item_stacks")
    private List<Map<String, Object>> itemStacks;

    /**
     * The list of commands to execute
     */
    @SerializedName("commands")
    private List<String> commands;

    /**
     * The list of messages to send
     * -- SETTER --
     * set the list of messages to send
     */
    @Setter
    @SerializedName("messages")
    private List<String> messages;

    /**
     * if there shall be a firework show
     * -- GETTER --
     * get if there is a firework show
     * -- SETTER --
     * set if there is a firework show
     */
    @Setter
    @Getter
    @SerializedName("firework_show")
    private boolean fireworkShow = false;

    /**
     * The amount of fireworks to spawn
     * -- GETTER --
     * get the amount of fireworks to spawn
     * -- SETTER --
     * set the amount of fireworks to spawn
     */
    @Setter
    @Getter
    @SerializedName("firework_show_amount")
    private int fireworkShowAmount = 1;

    /**
     * The seconds between the fireworks
     * -- SETTER --
     * set the seconds between the fireworks
     */
    @Setter
    @Getter
    @SerializedName("firework_show_seconds_between_firework")
    private int fireworkShowSecondsBetween = 0;

    public static Milestone getMilestone(String name) {
        return Playtime.getInstance()
                .getMilestones().stream()
                .filter(milestone -> milestone.getMilestoneName().equalsIgnoreCase(name))
                .findFirst().orElse(null);
    }

    /**
     * Apply the milestone on the player
     *
     * @param player The player to apply the milestone to
     */
    public void apply(Player player) {
        Bukkit.getScheduler().runTask(Playtime.getPlugin(), () ->
                Bukkit.getPluginManager().callEvent(
                        new MilestoneReceiveEvent(this, Playtime.getInstance().getPlaytimeUser(player.getUniqueId()).get()))
        );

        if (itemStacks != null && _itemStackObjects == null) {
            _itemStackObjects = new ArrayList<>();
            for (Map<String, Object> itemStack : itemStacks) {
                _itemStackObjects.add(ItemStack.deserialize(itemStack));
            }
        }

        if (_itemStackObjects != null && !_itemStackObjects.isEmpty()) {
            Bukkit.getScheduler().runTask(Playtime.getPlugin(), () ->
                    player.getInventory().addItem(_itemStackObjects.toArray(new ItemStack[0]))
            );
        }

        if (commands != null) {
            Bukkit.getScheduler().runTask(Playtime.getPlugin(), () ->
                    commands.forEach(command -> Bukkit.dispatchCommand(Bukkit.getConsoleSender(),
                            command.replaceAll("%playername%", player.getName())
                                    .replaceAll("%player_name%", player.getName())
                                    .replaceAll("%playeruuid%", player.getUniqueId().toString())
                                    .replaceAll("%player_uuid%", player.getUniqueId().toString()))
                    )
            );
        }

        if (messages != null) {
            messages.forEach(s ->
                    player.sendMessage(MessageUtil.translateHexColorCodes("<", ">", ChatColor.translateAlternateColorCodes('&', s)))
            );
        }

        if (fireworkShow) {
            Bukkit.getScheduler().runTaskAsynchronously(Playtime.getPlugin(), () -> {
                for (int i = 0; i < fireworkShowAmount; i++) {
                    Bukkit.getScheduler().runTask(Playtime.getPlugin(), () ->
                            FireworkUtil.spawnRandomFirework(player.getLocation())
                    );
                    try {
                        Thread.sleep(fireworkShowSecondsBetween * 1000L);
                    } catch (InterruptedException e) {
                        Playtime.getPlugin().getLogger().warning("Error while sleeping the thread: " + e.getMessage());
                    }
                }
            });
        }
    }

    /**
     * Adds an ItemStack to the milestone.
     *
     * @param itemStack The ItemStack to add.
     */
    public void addItemStack(ItemStack itemStack) {
        if (itemStacks == null) {
            itemStacks = new ArrayList<>();
        }
        itemStacks.add(itemStack.serialize());
        _itemStackObjects = null;
    }

    /**
     * Adds a command to the milestone.
     *
     * @param command The command to add.
     */
    public void addCommand(String command) {
        if (commands == null) {
            commands = new ArrayList<>();
        }
        commands.add(command);
    }

    /**
     * Adds a message to the milestone.
     *
     * @param message The message to add.
     */
    public void addMessage(String message) {
        if (messages == null) {
            messages = new ArrayList<>();
        }
        messages.add(message);
    }

    /**
     * Removes an ItemStack from the milestone.
     *
     * @param itemStack The ItemStack to remove.
     */
    public void removeItemStack(ItemStack itemStack) {
        if (itemStacks == null) {
            return;
        }
        itemStacks.remove(itemStack.serialize());
        _itemStackObjects = null;
    }

    public long getOnlineTimeInMilliseconds(){
        return onlineTime * 1000;
    }

    /**
     * Removes a command from the milestone.
     *
     * @param command The command to remove.
     */
    public void removeCommand(String command) {
        if (commands == null) {
            return;
        }
        commands.remove(command);
    }

    /**
     * Removes a message from the milestone.
     *
     * @param message The message to remove.
     */
    public void removeMessage(String message) {
        if (messages == null) {
            return;
        }
        messages.remove(message);
    }

    /**
     * @return The list of items to give the player.
     */
    public List<Map<String, Object>> getItemStacks() {
        if (itemStacks == null) {
            itemStacks = new ArrayList<>();
        }
        return itemStacks;
    }

    /**
     * @return The list of commands to execute
     */
    public List<String> getCommands() {
        if (commands == null) {
            commands = new ArrayList<>();
        }
        return commands;
    }

    /**
     * get the list of messages to send
     */
    public List<String> getMessages() {
        if (messages == null) {
            messages = new ArrayList<>();
        }
        return messages;
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/objects/MilestoneTest.java">
package nl.thedutchruben.playtime.core.objects;

import org.bukkit.entity.Player;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;
import org.bukkit.Bukkit;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import nl.thedutchruben.playtime.Playtime;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class MilestoneTest {

    private Milestone milestone;

    @Mock
    private Player mockPlayer;

    @Mock
    private PlayerInventory mockInventory;

    @Mock
    private Playtime mockPlaytime;

    @BeforeEach
    void setUp() {
        milestone = new Milestone();
        milestone.setMilestoneName("TestMilestone");
        milestone.setOnlineTime(3600); // 1 hour in seconds

        // Setup mock player
        when(mockPlayer.getInventory()).thenReturn(mockInventory);
        when(mockPlayer.getName()).thenReturn("TestPlayer");
        when(mockPlayer.getUniqueId()).thenReturn(UUID.randomUUID());
    }

    @Test
    void testGetOnlineTimeInMilliseconds() {
        assertEquals(3600 * 1000, milestone.getOnlineTimeInMilliseconds());
    }

    @Test
    void testAddCommand() {
        milestone.addCommand("give %playername% diamond 1");
        assertEquals(1, milestone.getCommands().size());
        assertEquals("give %playername% diamond 1", milestone.getCommands().get(0));
    }

    @Test
    void testAddMessage() {
        milestone.addMessage("Congratulations on reaching the milestone!");
        assertEquals(1, milestone.getMessages().size());
        assertEquals("Congratulations on reaching the milestone!", milestone.getMessages().get(0));
    }

    @Test
    void testRemoveCommand() {
        String command = "give %playername% diamond 1";
        milestone.addCommand(command);
        assertEquals(1, milestone.getCommands().size());

        milestone.removeCommand(command);
        assertEquals(0, milestone.getCommands().size());
    }

    @Test
    void testRemoveMessage() {
        String message = "Congratulations on reaching the milestone!";
        milestone.addMessage(message);
        assertEquals(1, milestone.getMessages().size());

        milestone.removeMessage(message);
        assertEquals(0, milestone.getMessages().size());
    }

    @Test
    void testFireworkSettings() {
        assertFalse(milestone.isFireworkShow());

        milestone.setFireworkShow(true);
        assertTrue(milestone.isFireworkShow());

        milestone.setFireworkShowAmount(5);
        assertEquals(5, milestone.getFireworkShowAmount());

        milestone.setFireworkShowSecondsBetween(2);
        assertEquals(2, milestone.getFireworkShowSecondsBetween());
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/objects/PlaytimeUser.java">
package nl.thedutchruben.playtime.core.objects;

import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.events.player.AsyncPlaytimePlayerUpdatePlaytimeEvent;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;

import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

@Getter
public class PlaytimeUser {

    @SerializedName("_id")
    public String uuid;
    public String name;
    public float time;
    private transient long lastChecked;

    /**
     * Constructs a PlaytimeUser with the specified UUID, name, and playtime.
     *
     * @param uuid The UUID of the user.
     * @param name The name of the user.
     * @param time The initial playtime of the user in milliseconds.
     */
    public PlaytimeUser(String uuid, String name, long time) {
        this.uuid = uuid;
        this.name = name;
        this.time = time;
        this.lastChecked = System.currentTimeMillis();
    }

    /**
     * Constructs a PlaytimeUser with the specified UUID and name.
     * The initial playtime is set to 0.
     *
     * @param uuid The UUID of the user.
     * @param name The name of the user.
     */
    public PlaytimeUser(String uuid, String name) {
        this(uuid, name, 0);
    }

    /**
     * Loads a PlaytimeUser asynchronously based on the specified UUID.
     *
     * @param uuid The UUID of the user to load.
     * @return A CompletableFuture that completes with the loaded PlaytimeUser.
     */
    public static CompletableFuture<PlaytimeUser> loadUser(UUID uuid) {
        return Playtime.getInstance().getStorage().loadUser(uuid);
    }

    /**
     * Updates the playtime of the user based on the time elapsed since the last check.
     * Fires an AsyncPlaytimePlayerUpdatePlaytimeEvent asynchronously.
     */
    public void updatePlaytime() {
        float oldTime = time;
        time = time + (System.currentTimeMillis() - lastChecked);
        Bukkit.getScheduler().runTaskAsynchronously(Playtime.getPlugin(),
                () -> Bukkit.getPluginManager().callEvent(new AsyncPlaytimePlayerUpdatePlaytimeEvent(this, true, oldTime, time)));
        lastChecked = System.currentTimeMillis();
    }

    /**
     * Returns the UUID of the user.
     *
     * @return The UUID of the user.
     */
    public UUID getUUID() {
        return UUID.fromString(this.uuid);
    }

    /**
     * Adds the specified amount of playtime to the user's total playtime.
     *
     * @param time     The amount of time to add.
     * @param timeUnit The unit of time.
     */
    public void addPlaytime(long time, TimeUnit timeUnit) {
        this.time = this.time + timeUnit.toMillis(time);
        lastChecked = System.currentTimeMillis();
    }

    /**
     * Saves the user's playtime data asynchronously.
     *
     * @return A CompletableFuture that completes when the save operation is done.
     */
    public CompletableFuture<Boolean> save() {
        return Playtime.getInstance().getStorage().saveUser(this);
    }

    /**
     * Removes the specified amount of playtime from the user's total playtime.
     *
     * @param time     The amount of time to remove.
     * @param timeUnit The unit of time.
     */
    public void removePlaytime(long time, TimeUnit timeUnit) {
        this.time = this.time - timeUnit.toMillis(time);
        lastChecked = System.currentTimeMillis();
    }

    /**
     * Sets the user's total playtime to the specified value.
     *
     * @param time The new total playtime in milliseconds.
     */
    public void setPlaytime(float time) {
        this.time = time;
    }

    /**
     * Returns the Bukkit Player object associated with the user.
     *
     * @return The Bukkit Player object.
     */
    public Player getBukkitPlayer() {
        return Bukkit.getPlayer(getUUID());
    }

    /**
     * Translates the user's total playtime into an array of days, hours, minutes, and seconds.
     *
     * @return An array containing the days, hours, minutes, and seconds of playtime.
     */
    public int[] translateTime() {
        float tempTime = this.time;
        tempTime = tempTime / 1000;
        int days = (int) (tempTime / 86400);
        tempTime = tempTime - days * 86400L;
        int hours = (int) (tempTime / 3600);
        tempTime = tempTime - hours * 3600L;
        int minutes = (int) (tempTime / 60);
        tempTime = tempTime - minutes * 60L;
        int seconds = (int) tempTime;
        return new int[]{days, hours, minutes, seconds};
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/objects/PlaytimeUserTest.java">
package nl.thedutchruben.playtime.core.objects;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;

import java.util.UUID;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class PlaytimeUserTest {

    private PlaytimeUser playtimeUser;
    private final UUID testUuid = UUID.randomUUID();
    private final String testName = "TestPlayer";

    @BeforeEach
    void setUp() {
        playtimeUser = new PlaytimeUser(testUuid.toString(), testName, 0);
    }

    @Test
    void testGetUUID() {
        assertEquals(testUuid, playtimeUser.getUUID());
    }

    @Test
    void testGetName() {
        assertEquals(testName, playtimeUser.getName());
    }

    @Test
    void testAddPlaytime() {
        // Test adding 1 hour
        playtimeUser.addPlaytime(1, TimeUnit.HOURS);
        assertEquals(TimeUnit.HOURS.toMillis(1), playtimeUser.getTime());

        // Test adding 30 minutes
        playtimeUser.addPlaytime(30, TimeUnit.MINUTES);
        assertEquals(TimeUnit.HOURS.toMillis(1) + TimeUnit.MINUTES.toMillis(30), playtimeUser.getTime());
    }

    @Test
    void testRemovePlaytime() {
        // Add 2 hours first
        playtimeUser.addPlaytime(2, TimeUnit.HOURS);

        // Remove 30 minutes
        playtimeUser.removePlaytime(30, TimeUnit.MINUTES);

        assertEquals(TimeUnit.HOURS.toMillis(2) - TimeUnit.MINUTES.toMillis(30), playtimeUser.getTime());
    }

    @Test
    void testSetPlaytime() {
        playtimeUser.setPlaytime(10000);
        assertEquals(10000, playtimeUser.getTime());
    }

    @Test
    void testTranslateTime() {
        // Set playtime to 1 day, 2 hours, 30 minutes, and 15 seconds
        long playtime =
                TimeUnit.DAYS.toMillis(1) +
                        TimeUnit.HOURS.toMillis(2) +
                        TimeUnit.MINUTES.toMillis(30) +
                        TimeUnit.SECONDS.toMillis(15);

        playtimeUser.setPlaytime(playtime);

        int[] time = playtimeUser.translateTime();

        assertEquals(1, time[0], "Days should be 1");
        assertEquals(2, time[1], "Hours should be 2");
        assertEquals(30, time[2], "Minutes should be 30");
        assertEquals(15, time[3], "Seconds should be 15");
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/objects/RepeatingMilestone.java">
package nl.thedutchruben.playtime.core.objects;

import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import lombok.Setter;
import nl.thedutchruben.mccore.utils.firework.FireworkUtil;
import nl.thedutchruben.mccore.utils.message.MessageUtil;
import nl.thedutchruben.playtime.Playtime;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * @author Ruben
 * @version 1.0
 */
public class RepeatingMilestone {

    /**
     * The list of items to give the player.
     */
    private transient List<ItemStack> _itemStackObjects;

    /**
     * The name of the milestone.
     */
    @Setter
    @SerializedName("_id")
    private String milestoneName;
    @Setter
    @Getter
    @SerializedName("online_time")
    private long onlineTime;
    @SerializedName("item_stacks")
    private List<Map<String, Object>> itemStacks;
    @SerializedName("commands")
    private List<String> commands;
    @SerializedName("firework_show")
    private boolean fireworkShow = false;
    @SerializedName("firework_show_amount")
    private int fireworkShowAmount = 1;
    @Setter
    @SerializedName("firework_show_seconds_between_firework")
    private int fireworkShowSecondsBetween = 0;
    @Getter
    @SerializedName("normal_milestone_override_me")
    private boolean overrideMe = false;
    @SerializedName("messages")
    private List<String> messages;

    /**
     * Apply the milestone on the player
     *
     * @param player The player to apply the milestone to
     */
    public void apply(Player player) {
        if (itemStacks != null) {
            if (_itemStackObjects == null) {
                _itemStackObjects = new ArrayList<>();
                for (Map<String, Object> itemStack : itemStacks) {
                    _itemStackObjects.add(ItemStack.deserialize(itemStack));
                }
            }

            for (ItemStack itemStack : _itemStackObjects) {
                player.getInventory().addItem(itemStack);
            }
        }

        if (commands != null) {
            Bukkit.getScheduler().runTask(Playtime.getPlugin(), () -> {
                for (String command : commands) {
                    Bukkit.dispatchCommand(Bukkit.getConsoleSender(),
                            command.replaceAll("%playername%", player.getName())
                                    .replaceAll("%player_name%", player.getName())
                                    .replaceAll("%playeruuid%", player.getUniqueId().toString())
                                    .replaceAll("%player_uuid%", player.getUniqueId().toString()));
                }
            });
        }

        if (messages != null) {
            messages.forEach(s -> {
                String formattedString = MessageUtil.translateHexColorCodes("<", ">", ChatColor.translateAlternateColorCodes('&', s));
                player.sendMessage(formattedString);
            });
        }

        if (fireworkShow) {
            Bukkit.getScheduler().runTaskAsynchronously(Playtime.getPlugin(), () -> {
                for (int i = 0; i < fireworkShowAmount; i++) {
                    Bukkit.getScheduler().runTask(Playtime.getPlugin(), () -> {
                        FireworkUtil.spawnRandomFirework(player.getLocation());
                    });
                    try {
                        Thread.sleep(fireworkShowSecondsBetween * 1000L);
                    } catch (InterruptedException e) {
                        Playtime.getPlugin().getLogger().warning("Error while sleeping the thread :" + e.getMessage());
                    }
                }
            });

        }
    }

    public List<Map<String, Object>> getItemStacks() {
        if (itemStacks == null) {
            itemStacks = new ArrayList<>();
        }
        return itemStacks;
    }

    public void setItemStacks(List<Map<String, Object>> itemStacks) {
        this.itemStacks = itemStacks;
    }

    public List<String> getCommands() {
        if (commands == null) {
            commands = new ArrayList<>();
        }
        return commands;
    }

    public void setCommands(List<String> commands) {
        this.commands = commands;
    }

    public String getMilestoneName() {
        return milestoneName;
    }

    public List<String> getMessages() {
        if (messages == null)
            messages = new ArrayList<>();

        return messages;
    }

    public long getOnlineTimeInMilliseconds(){
        return onlineTime * 1000;
    }

    public void setMessages(List<String> messages) {
        this.messages = messages;
    }

    public void setItemStackObjects(List<ItemStack> itemStackObjects) {
        this._itemStackObjects = itemStackObjects;
    }

    public boolean isFireworkShow() {
        return fireworkShow;
    }

    public void setFireworkShow(boolean fireworkShow) {
        this.fireworkShow = fireworkShow;
    }

    public int getFireworkShowAmount() {
        return fireworkShowAmount;
    }

    public void setFireworkShowAmount(int fireworkShowAmount) {
        this.fireworkShowAmount = fireworkShowAmount;
    }

    public int getFireworkShowSecondsBetween() {
        return fireworkShowSecondsBetween;
    }

    public void setOverrideMe(boolean overrideMe) {
        this.overrideMe = overrideMe;
    }

    /**
     * Add an ItemStack to the milestone
     * @param itemStack The itemStack to add
     */
    public void addItemStack(ItemStack itemStack) {
        getItemStacks().add(itemStack.serialize());
    }

    /**
     * Add a command to the milestone
     * @param command The command to add
     */
    public void addCommand(String command) {
        getCommands().add(command);
    }

    /**
     * Remove a command from the milestone
     * @param command The command to remove
     */
    public void removeCommand(String command) {
        getCommands().remove(command);
    }

    /**
     * Add a message to the milestone
     *
     * @param message The message to add
     */
    public void addMessage(String message) {
        getMessages().add(message);
    }

    /**
     * Remove a message from the milestone
     *
     * @param message The message to remove
     */
    public void removeMessage(String message) {
        getMessages().remove(message);
    }

    /**
     * Get a milestone by name
     *
     * @param name The name of the milestone
     * @see RepeatingMilestone
     * @return The milestone
     */
    public static RepeatingMilestone get(String name) {
        return Playtime.getInstance()
                .getRepeatingMilestones().stream()
                .filter(milestone -> milestone.getMilestoneName().equalsIgnoreCase(name))
                .findFirst().orElse(null);
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/Settings.java">
package nl.thedutchruben.playtime.core;

import lombok.Getter;
import nl.thedutchruben.playtime.Playtime;
import org.bukkit.configuration.file.YamlConfiguration;

@Getter
public enum Settings {

    UPDATE_CHECK("settings.update-check", true, 1.0, ConfigFiles.CONFIG),
    CACHE_TIME("settings.cache-time", 5, 1.0, ConfigFiles.CONFIG),
    AFK_COUNT_TIME("settings.afk.countAfkTime", true, 1.0, ConfigFiles.CONFIG),
    AFK_USE_ESSENTIALS_API("settings.afk.useEssentialsApi", false, 1.0, ConfigFiles.CONFIG),
    AFK_EVENTS_CHAT("settings.afk.events.chatResetAfkTime", true, 1.0, ConfigFiles.CONFIG),
    TOP_10_PLACEHOLDER_CACHE_TIME("settings.top_10_placeholder_cache_time", 600, 1.0, ConfigFiles.CONFIG),
    STORAGE_TYPE("type", "sqllite", 1.0, ConfigFiles.STORAGE),

    STORAGE_MYSQL_HOST("mysql.hostname", "localhost", 1.0, ConfigFiles.STORAGE),
    STORAGE_MYSQL_PORT("mysql.port", 3306, 1.0, ConfigFiles.STORAGE),
    STORAGE_MYSQL_USERNAME("mysql.username", "username", 1.0, ConfigFiles.STORAGE),
    STORAGE_MYSQL_PASSWORD("mysql.password", "password", 1.0, ConfigFiles.STORAGE),
    STORAGE_MYSQL_SSL("mysql.ssl", true, 1.0, ConfigFiles.STORAGE),
    STORAGE_MYSQL_SCHEMA("mysql.schema", "playtime", 1.0, ConfigFiles.STORAGE),
    STORAGE_MYSQL_PREFIX("mysql.prefix", "", 1.0, ConfigFiles.STORAGE),
    STORAGE_MYSQL_POOL("mysql.pool", 20, 1.0, ConfigFiles.STORAGE),
    STORAGE_MYSQL_DRIVER("mysql.driver", "jdbc:mysql://", 1.0, ConfigFiles.STORAGE),

    STORAGE_MONGO_HOST("mongo.hostname", "localhost", 1.0, ConfigFiles.STORAGE),
    STORAGE_MONGO_PORT("mongo.port", 27017, 1.0, ConfigFiles.STORAGE),
    STORAGE_MONGO_USERNAME("mongo.username", "username", 1.0, ConfigFiles.STORAGE),
    STORAGE_MONGO_PASSWORD("mongo.password", "password", 1.0, ConfigFiles.STORAGE),
    STORAGE_MONGO_COLLECTION("mongo.collection", "playtime", 1.0, ConfigFiles.STORAGE);

    private final String path;
    private final Object defaultValue;
    private final String fileName;
    private final double version;

    Settings(String path, Object defaultValue, double version, ConfigFiles configFile) {
        this.path = path;
        this.defaultValue = defaultValue;
        this.fileName = configFile.getFileName();
        this.version = version;
    }

    /**
     * Set up the default config
     */
    public static void setupDefaults() {
        for (Settings value : Settings.values()) {
            YamlConfiguration yamlConfiguration = Playtime.getInstance().getFileManager().getConfig(value.getFileName()).get();
            if (yamlConfiguration.get(value.getPath()) == null) {
                yamlConfiguration.set(value.getPath(), value.getDefaultValue());
                Playtime.getInstance().getFileManager().getConfig(value.getFileName()).save();
            }
        }
    }

    /**
     * Get the config
     *
     * @param fileName the file name
     * @return the config
     */
    public YamlConfiguration getConfig(String fileName) {
        return Playtime.getInstance().getFileManager().getConfig(fileName).get();
    }

    public Object getValue() {
        return getConfig(this.fileName).get(path, defaultValue);
    }

    public String getValueAsString() {
        return getConfig(this.fileName).getString(path, (String) defaultValue);
    }

    public Boolean getValueAsBoolean() {
        return getConfig(this.fileName).getBoolean(path, (Boolean) defaultValue);
    }

    public Integer getValueAsInteger() {
        return getConfig(this.fileName).getInt(path, (Integer) defaultValue);
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/storage/exceptions/StorageTypeNotFoundException.java">
package nl.thedutchruben.playtime.core.storage.exceptions;

/**
 * Thrown when a storage type is not found
 */
public class StorageTypeNotFoundException extends RuntimeException {

    /**
     * Create a new StorageTypeNotFoundException
     * @param message The message to display
     */
    public StorageTypeNotFoundException(String message) {
        super(message);
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/storage/SqlStatements.java">
package nl.thedutchruben.playtime.core.storage;

import java.util.ArrayList;
import java.util.List;

/**
 * This class contains the SQL statements that are used to create the tables in the database.
 * The statements are formatted based on the table prefix and the database type.
 */
public class SqlStatements {

    /**
     * Get the SQL statements for creating the tables in the database.
     *
     * @param tablePrefix The prefix for the table names.
     * @param mysql       Whether the database is MySQL or SQLite.
     * @return The SQL statements for creating the tables in the database.
     */
    public static List<String> getStatements(String tablePrefix, boolean mysql) {
        List<String> statements = new ArrayList<>();
        String prefix = "CREATE TABLE IF NOT EXISTS `" + tablePrefix;
        statements.add(String.format("%splaytime` (\n  `uuid` varchar(36),\n  `name` varchar(16),\n  `time` BIGINT \n);\n", prefix));
        statements.add(String.format("%smilestones` (\n  `name` varchar(40),\n  `data` TEXT \n);\n", prefix));
        statements.add(String.format("%srepeating_milestones` (\n  `name` varchar(40),\n  `data` TEXT \n);\n", prefix));
        statements.add(String.format("%splaytime_milestones` (\n  `uuid` varchar(36),\n  `milestone` varchar(40),\n  `claimed` BOOLEAN \n);\n", prefix));

        String playtimeHistory = mysql
                ? String.format("%splaytime_history` (\n  `id` INT NOT NULL AUTO_INCREMENT , \n  `uuid` VARCHAR(40) NOT NULL \n,  `event` VARCHAR(40) NOT NULL , \n  `start_time` BIGINT NOT NULL , \n  `date` DATETIME NOT NULL , \n  PRIMARY KEY (`id`)) ENGINE = InnoDB;", prefix)
                : String.format("CREATE TABLE IF NOT EXISTS `%splaytime_history` (\n" +
                "  `id` INTEGER PRIMARY KEY AUTOINCREMENT,\n" +
                "  `uuid` VARCHAR(40),\n" +
                "  `time` BIGINT,\n" +
                "  `event` VARCHAR(40),\n" +
                "  `date` DATETIME\n" +
                ");", tablePrefix);
        statements.add(playtimeHistory);

        return statements;
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/storage/Storage.java">
package nl.thedutchruben.playtime.core.storage;

import com.google.gson.Gson;
import nl.thedutchruben.mccore.utils.GsonUtil;
import nl.thedutchruben.playtime.core.objects.Milestone;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import nl.thedutchruben.playtime.core.objects.RepeatingMilestone;

import java.util.List;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

public abstract class Storage {
    private final Gson gson;

    public Storage() {
        this.gson =  GsonUtil.createGson();
    }

    /**
     * Get the name of the storage type
     *
     * @return The name of the storage type
     */
    public abstract String getName();

    /**
     * Set up the storage such as the database connection
     */
    public abstract boolean setup();

    /**
     * Stops the storage such things as the database connection
     */
    public abstract void stop();

    /**
     * Load the user from the storage
     *
     * @param uuid The uuid of the player
     * @return The playtime user
     */

    public abstract CompletableFuture<PlaytimeUser> loadUser(UUID uuid);

    /**
     * Load user loaded by name
     *
     * @param name
     * @return
     */
    public abstract CompletableFuture<PlaytimeUser> loadUserByName(String name);

    /**
     * Save the user to the storage
     *
     * @param playtimeUser The playtime user
     * @return If the user is saved
     */
    public abstract CompletableFuture<Boolean> saveUser(PlaytimeUser playtimeUser);

    /**
     * Create the user
     *
     * @param playtimeUser
     * @return
     */
    public abstract CompletableFuture<Boolean> createUser(PlaytimeUser playtimeUser);

    /**
     * Get the top users
     *
     * @param amount The amount of users
     * @param skip   The amount of users to skip
     * @return The list of users
     */
    public abstract CompletableFuture<List<PlaytimeUser>> getTopUsers(int amount, int skip);

    /**
     * Get the top user
     *
     * @param place The place of the user
     * @return The user
     */
    public abstract CompletableFuture<PlaytimeUser> getTopUser(int place);

    /**
     * Get the milestones
     *
     * @return The list of milestones
     */
    public abstract CompletableFuture<List<Milestone>> getMilestones();

    /**
     * Save the milestone
     *
     * @param milestone The milestone to save
     * @return If the milestone is saved
     */
    public abstract CompletableFuture<Boolean> saveMilestone(Milestone milestone);

    /**
     * Delete the milestone
     *
     * @param milestone The milestone to delete
     * @return If the milestone is deleted
     */
    public abstract CompletableFuture<Boolean> deleteMilestone(Milestone milestone);

    /**
     * Update the milestone
     *
     * @param milestone The milestone to update
     * @return If the milestone is updated
     */
    public abstract CompletableFuture<Boolean> updateMilestone(Milestone milestone);

    /**
     * Get the repeating milestones
     *
     * @return The list of repeating milestones
     */
    public abstract CompletableFuture<List<RepeatingMilestone>> getRepeatingMilestones();

    /**
     * Save the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to save
     * @return If the repeating milestone is saved
     */
    public abstract CompletableFuture<Boolean> saveRepeatingMilestone(RepeatingMilestone repeatingMilestone);

    /**
     * Delete the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to delete
     * @return If the repeating milestone is deleted
     */
    public abstract CompletableFuture<Boolean> deleteRepeatingMilestone(RepeatingMilestone repeatingMilestone);

    /**
     * Update the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to update
     * @return If the repeating milestone is updated
     */
    public abstract CompletableFuture<Boolean> updateRepeatingMilestone(RepeatingMilestone repeatingMilestone);

    /**
     *
     * @param uuid
     * @param event
     * @param time
     * @return
     */
    public abstract CompletableFuture<Boolean> addPlaytimeHistory(UUID uuid, Event event, int time);

    public Gson getGson() {
        return gson;
    }

    public enum Event {
        JOIN,
        QUIT
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/storage/types/Mongodb.java">
package nl.thedutchruben.playtime.core.storage.types;

import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.client.result.DeleteResult;
import com.mongodb.client.result.InsertOneResult;
import com.mongodb.client.result.UpdateResult;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.Settings;
import nl.thedutchruben.playtime.core.objects.Milestone;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import nl.thedutchruben.playtime.core.objects.RepeatingMilestone;
import nl.thedutchruben.playtime.core.storage.Storage;
import org.bson.Document;

import java.util.*;
import java.util.concurrent.CompletableFuture;

/**
 * The mongodb storage
 */
public class Mongodb extends Storage {
    private MongoClient mongoClient;
    private com.mongodb.client.MongoDatabase database;

    /**
     * Get the name of the storage type
     *
     * @return The name of the storage type
     */
    @Override
    public String getName() {
        return "mongodb";
    }

    /**
     * Setup the storage such as the database connection
     */
    @Override
    public boolean setup() {
        // build the connection string from config values
        String connectionString = "mongodb://";
        if (!Objects.equals(Settings.STORAGE_MONGO_USERNAME.getValueAsString(), "")) {
            connectionString += Settings.STORAGE_MONGO_USERNAME.getValueAsString() + ":" + Settings.STORAGE_MONGO_PASSWORD.getValueAsString() + "@";
        }
        connectionString += Settings.STORAGE_MONGO_HOST.getValueAsString() + ":" + Settings.STORAGE_MONGO_PORT.getValueAsInteger();
        connectionString += "/" + Settings.STORAGE_MONGO_COLLECTION.getValueAsString();
        this.mongoClient = MongoClients.create(connectionString);
        //Check if the database is valid
        this.database = this.mongoClient.getDatabase(Settings.STORAGE_MONGO_COLLECTION.getValueAsString());

        return this.mongoClient != null;
    }

    /**
     * Stops the storage such things as the database connection
     */
    @Override
    public void stop() {
        this.mongoClient.close();
    }

    /**
     * Load the user from the storage
     *
     * @param uuid The uuid of the player
     * @return The playtime user
     */
    @Override
    public CompletableFuture<PlaytimeUser> loadUser(UUID uuid) {
        return CompletableFuture.supplyAsync(() -> {
            Document document = this.database.getCollection("playtime").find(new Document("uuid", uuid.toString())).first();
            if (document == null) {
                return null;
            }
            return new PlaytimeUser(document.getString("uuid"), document.getString("name"), document.getLong("playtime"));
        });
    }

    /**
     * Load user loaded by name
     *
     * @param name
     * @return
     */
    @Override
    public CompletableFuture<PlaytimeUser> loadUserByName(String name) {
        return CompletableFuture.supplyAsync(() -> {
            Document document = this.database.getCollection("playtime").find(new Document("name", name)).first();
            if (document == null) {
                return null;
            }
            return new PlaytimeUser(document.getString("uuid"), document.getString("name"), document.getLong("playtime"));
        });
    }

    /**
     * Save the user to the storage
     *
     * @param playtimeUser The playtime user
     * @return If the user is saved
     */
    @Override
    public CompletableFuture<Boolean> saveUser(PlaytimeUser playtimeUser) {
        return CompletableFuture.supplyAsync(() -> {
            Document document = new Document("uuid", playtimeUser.getUUID().toString())
                    .append("name", playtimeUser.getName())
                    .append("playtime", playtimeUser.getTime());
            UpdateResult updateResult = this.database.getCollection("playtime").updateOne(new Document("uuid", playtimeUser.getUUID().toString()), new Document("$set", document));
            return updateResult.wasAcknowledged();
        });
    }


    /**
     * Create the user
     *
     * @param playtimeUser
     * @return
     */
    @Override
    public CompletableFuture<Boolean> createUser(PlaytimeUser playtimeUser) {
        return CompletableFuture.supplyAsync(() -> {
            Document document = new Document("uuid", playtimeUser.getUUID().toString())
                    .append("name", playtimeUser.getName())
                    .append("playtime", playtimeUser.getTime());
            InsertOneResult result = this.database.getCollection("playtime").insertOne(document);
            return result.wasAcknowledged();
        });
    }

    /**
     * Get the top users
     *
     * @param amount The amount of users
     * @param skip   The amount of users to skip
     * @return The list of users
     */
    @Override
    public CompletableFuture<List<PlaytimeUser>> getTopUsers(int amount, int skip) {
        return CompletableFuture.supplyAsync(() -> {
            List<PlaytimeUser> users = new ArrayList<>();
            this.database.getCollection("playtime").find().sort(new Document("playtime", -1)).skip(skip).limit(amount).forEach(document -> {
                users.add(new PlaytimeUser(document.getString("uuid"), document.getString("name"), document.getLong("playtime")));
            });
            return users;
        });
    }

    /**
     * Get the top user
     *
     * @param place The place of the user
     * @return The user
     */
    @Override
    public CompletableFuture<PlaytimeUser> getTopUser(int place) {
        return CompletableFuture.supplyAsync(() -> {
            Document document = this.database.getCollection("playtime").find().sort(new Document("playtime", -1)).skip(place).limit(1).first();
            if (document == null) {
                return null;
            }
            return new PlaytimeUser(document.getString("uuid"), document.getString("name"), document.getLong("playtime"));
        });
    }

    /**
     * Get the milestones
     *
     * @return The list of milestones
     */
    @Override
    public CompletableFuture<List<Milestone>> getMilestones() {
        return CompletableFuture.supplyAsync(() -> this.database.getCollection("milestones").find().map(document -> getGson().fromJson(document.toJson(), Milestone.class)).into(new ArrayList<>()));
    }

    /**
     * Save the milestone
     *
     * @param milestone The milestone to save
     * @return If the milestone is saved
     */
    @Override
    public CompletableFuture<Boolean> saveMilestone(Milestone milestone) {
        return CompletableFuture.supplyAsync(() -> {
            Document document = Document.parse(getGson().toJson(milestone));
            InsertOneResult result = this.database.getCollection("milestones").insertOne(document);
            return result.wasAcknowledged();
        });
    }

    /**
     * Delete the milestone
     *
     * @param milestone The milestone to delete
     * @return If the milestone is deleted
     */
    @Override
    public CompletableFuture<Boolean> deleteMilestone(Milestone milestone) {
        return CompletableFuture.supplyAsync(() -> {
            Document document = Document.parse(getGson().toJson(milestone));
            DeleteResult deleteResult = this.database.getCollection("milestones").deleteOne(document);
            return deleteResult.wasAcknowledged();
        });
    }

    /**
     * Update the milestone
     *
     * @param milestone The milestone to update
     * @return If the milestone is updated
     */
    @Override
    public CompletableFuture<Boolean> updateMilestone(Milestone milestone) {
        return CompletableFuture.supplyAsync(() -> {
            Document document = Document.parse(getGson().toJson(milestone, Milestone.class));
            UpdateResult insertOneResult = this.database.getCollection("milestones").updateOne(new Document("_id", milestone.getMilestoneName()), new Document("$set", document));
            return insertOneResult.wasAcknowledged();
        });
    }

    /**
     * Get the repeating milestones
     *
     * @return The list of repeating milestones
     */
    @Override
    public CompletableFuture<List<RepeatingMilestone>> getRepeatingMilestones() {
        return CompletableFuture.supplyAsync(() -> this.database.getCollection("repeatingmilestones").find().map(document -> getGson().fromJson(document.toJson(), RepeatingMilestone.class)).into(new ArrayList<>()));
    }

    /**
     * Save the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to save
     * @return If the repeating milestone is saved
     */
    @Override
    public CompletableFuture<Boolean> saveRepeatingMilestone(RepeatingMilestone repeatingMilestone) {
        return CompletableFuture.supplyAsync(() -> {
            Document document = Document.parse(getGson().toJson(repeatingMilestone));
            InsertOneResult result = this.database.getCollection("repeatingmilestones").insertOne(document);
            return result.wasAcknowledged();
        });
    }

    /**
     * Delete the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to delete
     * @return If the repeating milestone is deleted
     */
    @Override
    public CompletableFuture<Boolean> deleteRepeatingMilestone(RepeatingMilestone repeatingMilestone) {
        return CompletableFuture.supplyAsync(() -> {
            Document document = Document.parse(getGson().toJson(repeatingMilestone));
            DeleteResult deleteResult = this.database.getCollection("repeatingmilestones").deleteOne(document);
            return deleteResult.wasAcknowledged();
        });
    }

    /**
     * Update the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to update
     * @return If the repeating milestone is updated
     */
    @Override
    public CompletableFuture<Boolean> updateRepeatingMilestone(RepeatingMilestone repeatingMilestone) {
        return CompletableFuture.supplyAsync(() -> {
            Document document = Document.parse(getGson().toJson(repeatingMilestone, RepeatingMilestone.class));
            UpdateResult insertOneResult = this.database.getCollection("repeatingmilestones").updateOne(new Document("_id", repeatingMilestone.getMilestoneName()), new Document("$set", document));
            return insertOneResult.wasAcknowledged();
        });
    }

    /**
     * @param uuid
     * @param event
     * @param time
     * @return
     */
    @Override
    public CompletableFuture<Boolean> addPlaytimeHistory(UUID uuid, Event event, int time) {
        return CompletableFuture.supplyAsync(() -> {
            InsertOneResult result = this.database.getCollection("playtimeHistory")
                    .insertOne(
                            new Document("uuid", uuid)
                                    .append("date", new Date())
                                    .append("event", event)
                                    .append("time", time)
                    );
            return result.wasAcknowledged();
        });
    }

    /**
     * Check if a playtime record exists for the specified player and date
     *
     * @param uuid The UUID of the player
     * @param date The date to check
     * @return If the record exists
     */
    private boolean playtimeRecordExists(UUID uuid, java.sql.Date date) {
        Document query = new Document("uuid", uuid.toString()).append("date", date);
        return this.database.getCollection("playtime_history").find(query).first() != null;
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/storage/types/Mysql.java">
package nl.thedutchruben.playtime.core.storage.types;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.Settings;
import nl.thedutchruben.playtime.core.objects.Milestone;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import nl.thedutchruben.playtime.core.objects.RepeatingMilestone;
import nl.thedutchruben.playtime.core.storage.SqlStatements;
import nl.thedutchruben.playtime.core.storage.Storage;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;
import java.util.concurrent.CompletableFuture;

/**
 * The mysql storage
 */
public class Mysql extends Storage {
    private HikariDataSource ds;
    private Connection connection;

    private String tablePrefix = "";

    /**
     * Get the name of the storage type
     *
     * @return The name of the storage type
     */
    @Override
    public String getName() {
        return "mysql";
    }

    /**
     * Setup the storage such as the database connection
     */
    @Override
    public boolean setup() {
        this.tablePrefix = Settings.STORAGE_MYSQL_PREFIX.getValueAsString();
        HikariConfig config = getHikariConfig();
        ds = new HikariDataSource(config);

        try {
            this.connection = ds.getConnection();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        for (String statement : SqlStatements.getStatements(Settings.STORAGE_MYSQL_PREFIX.getValueAsString(), true)) {
            try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
                preparedStatement.executeUpdate();
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while creating table in database: " + sqlException.getMessage());
            }
        }
        return ds.isRunning();
    }

    private static HikariConfig getHikariConfig() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(Settings.STORAGE_MYSQL_DRIVER.getValueAsString() + Settings.STORAGE_MYSQL_HOST.getValueAsString() + ":" + Settings.STORAGE_MYSQL_PORT.getValueAsInteger() + "/" + Settings.STORAGE_MYSQL_SCHEMA.getValueAsString());
        config.setConnectionTestQuery("SELECT 1");
        config.setUsername(Settings.STORAGE_MYSQL_USERNAME.getValueAsString());
        config.setPassword(Settings.STORAGE_MYSQL_PASSWORD.getValueAsString());
        config.setMaximumPoolSize(Settings.STORAGE_MYSQL_POOL.getValueAsInteger());

        config.setPoolName("PlaytimePool");
        config.addDataSourceProperty("useSSl", (Settings.STORAGE_MYSQL_SSL.getValueAsBoolean()));
        config.setThreadFactory(r -> {
            Thread thread = new Thread(r);
            thread.setName("Playtime-Database-Thread-" + thread.getId());
            return thread;
        });

        return config;
    }

    /**
     * Get the table name with the prefix
     *
     * @param name The name of the table
     * @return The table name with the prefix
     */
    public String getTableName(String name) {
        return "`" + this.tablePrefix + name + "`";
    }

    /**
     * Stops the storage such things as the database connection
     */
    @Override
    public void stop() {
        ds.close();
    }

    /**
     * Load the user from the storage
     *
     * @param uuid The uuid of the player
     * @return The playtime user
     */
    @Override
    public CompletableFuture<PlaytimeUser> loadUser(UUID uuid) {
        return CompletableFuture.supplyAsync(() -> {

            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("SELECT * FROM " + getTableName("playtime") + " WHERE `uuid` = ?")) {
                preparedStatement.setString(1, uuid.toString());
                try (ResultSet resultSet = preparedStatement.executeQuery()) {
                    if (resultSet.next()) {
                        return new PlaytimeUser(uuid.toString(), resultSet.getString("name"), resultSet.getLong("time"));
                    }
                }
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while loading user from database: " + sqlException.getMessage());
            }
            return null;
        });
    }

    /**
     * Load user loaded by name
     *
     * @param name
     * @return
     */
    @Override
    public CompletableFuture<PlaytimeUser> loadUserByName(String name) {
        return CompletableFuture.supplyAsync(() -> {

            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("SELECT * FROM " + getTableName("playtime") + " WHERE `name` = ?")) {
                preparedStatement.setString(1, name);
                try (ResultSet resultSet = preparedStatement.executeQuery()) {
                    if (resultSet.next()) {
                        return new PlaytimeUser(resultSet.getString("uuid"), resultSet.getString("name"), resultSet.getLong("time"));
                    }
                }
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while loading user from database: " + sqlException.getMessage());
            }
            return null;
        });
    }

    /**
     * Save the user to the storage
     *
     * @param playtimeUser The playtime user
     * @return If the user is saved
     */
    @Override
    public CompletableFuture<Boolean> saveUser(PlaytimeUser playtimeUser) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("UPDATE " + getTableName("playtime") + " SET `name` = ?, `time` = ? WHERE `uuid` = ?")) {
                preparedStatement.setString(1, playtimeUser.getName());
                preparedStatement.setFloat(2, playtimeUser.getTime());
                preparedStatement.setString(3, playtimeUser.getUUID().toString());
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while saving user to database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Create the user
     *
     * @param playtimeUser
     * @return
     */
    @Override
    public CompletableFuture<Boolean> createUser(PlaytimeUser playtimeUser) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("INSERT INTO " + getTableName("playtime") + " (`uuid`, `name`, `time`) VALUES (?, ?, ?)")) {
                preparedStatement.setString(1, playtimeUser.getUUID().toString());
                preparedStatement.setString(2, playtimeUser.getName());
                preparedStatement.setFloat(3, playtimeUser.getTime());
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while creating user in database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Get the top users
     *
     * @param amount The amount of users
     * @param skip   The amount of users to skip
     * @return The list of users
     */
    @Override
    public CompletableFuture<List<PlaytimeUser>> getTopUsers(int amount, int skip) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("SELECT * FROM " + getTableName("playtime") + " ORDER BY `time` DESC LIMIT ? OFFSET ?")) {
                preparedStatement.setInt(1, amount);
                preparedStatement.setInt(2, skip);
                try (ResultSet resultSet = preparedStatement.executeQuery()) {
                    List<PlaytimeUser> playtimeUsers = new ArrayList<>();
                    while (resultSet.next()) {
                        playtimeUsers.add(new PlaytimeUser(resultSet.getString("uuid"), resultSet.getString("name"), resultSet.getLong("time")));
                    }
                    return playtimeUsers;
                }
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while getting top users from database: " + sqlException.getMessage());
            }
            return null;
        });
    }

    /**
     * Get the top user
     *
     * @param place The place of the user
     * @return The user
     */
    @Override
    public CompletableFuture<PlaytimeUser> getTopUser(int place) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("SELECT * FROM " + getTableName("playtime") + " ORDER BY `time` DESC LIMIT 1 OFFSET ?")) {
                preparedStatement.setInt(1, place);
                try (ResultSet resultSet = preparedStatement.executeQuery()) {
                    if (resultSet.next()) {
                        return new PlaytimeUser(resultSet.getString("uuid"), resultSet.getString("name"), resultSet.getLong("time"));
                    }
                }
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while getting top user from database: " + sqlException.getMessage());
            }
            return null;
        });
    }

    /**
     * Get the milestones
     *
     * @return The list of milestones
     */
    @Override
    public CompletableFuture<List<Milestone>> getMilestones() {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("SELECT * FROM " + getTableName("milestones"))) {
                try (ResultSet resultSet = preparedStatement.executeQuery()) {
                    List<Milestone> milestones = new ArrayList<>();
                    while (resultSet.next()) {
                        milestones.add(getGson().fromJson(resultSet.getString("data"), Milestone.class));
                    }
                    return milestones;
                }
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while getting milestones from database: " + sqlException.getMessage());
            }
            return null;
        });
    }

    /**
     * Save the milestone
     *
     * @param milestone The milestone to save
     * @return If the milestone is saved
     */
    @Override
    public CompletableFuture<Boolean> saveMilestone(Milestone milestone) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("INSERT INTO " + getTableName("milestones") + "(`name`, `data`) VALUES (?,?)")) {
                preparedStatement.setString(1, milestone.getMilestoneName());
                preparedStatement.setString(2, getGson().toJson(milestone));
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while saving milestone to database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Delete the milestone
     *
     * @param milestone The milestone to delete
     * @return If the milestone is deleted
     */
    @Override
    public CompletableFuture<Boolean> deleteMilestone(Milestone milestone) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("DELETE FROM " + getTableName("milestones") + " WHERE `name`=?")) {
                preparedStatement.setString(1, milestone.getMilestoneName());
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while deleting milestone from database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Update the milestone
     *
     * @param milestone The milestone to update
     * @return If the milestone is updated
     */
    @Override
    public CompletableFuture<Boolean> updateMilestone(Milestone milestone) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("UPDATE " + getTableName("milestones") + " SET `data`=? WHERE `name`=?")) {
                preparedStatement.setString(1, getGson().toJson(milestone));
                preparedStatement.setString(2, milestone.getMilestoneName());
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while updating milestone to database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Get the repeating milestones
     *
     * @return The list of repeating milestones
     */
    @Override
    public CompletableFuture<List<RepeatingMilestone>> getRepeatingMilestones() {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("SELECT * FROM " + getTableName("repeating_milestones"))) {
                try (ResultSet resultSet = preparedStatement.executeQuery()) {
                    List<RepeatingMilestone> repeatingMilestones = new ArrayList<>();
                    while (resultSet.next()) {
                        repeatingMilestones.add(getGson().fromJson(resultSet.getString("data"), RepeatingMilestone.class));
                    }
                    return repeatingMilestones;
                }
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while getting repeating milestones from database: " + sqlException.getMessage());
            }
            return null;
        });
    }

    /**
     * Save the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to save
     * @return If the repeating milestone is saved
     */
    @Override
    public CompletableFuture<Boolean> saveRepeatingMilestone(RepeatingMilestone repeatingMilestone) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("INSERT INTO " + getTableName("repeating_milestones") + "`(`name`, `data`) VALUES (?,?)")) {
                preparedStatement.setString(1, repeatingMilestone.getMilestoneName());
                preparedStatement.setString(2, getGson().toJson(repeatingMilestone));
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while saving repeating milestone to database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Delete the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to delete
     * @return If the repeating milestone is deleted
     */
    @Override
    public CompletableFuture<Boolean> deleteRepeatingMilestone(RepeatingMilestone repeatingMilestone) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("DELETE FROM " + getTableName("repeating_milestones") + " WHERE `name`=?")) {
                preparedStatement.setString(1, repeatingMilestone.getMilestoneName());
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while deleting repeating milestone from database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Update the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to update
     * @return If the repeating milestone is updated
     */
    @Override
    public CompletableFuture<Boolean> updateRepeatingMilestone(RepeatingMilestone repeatingMilestone) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("UPDATE " + getTableName("repeating_milestones") + " SET `data`=? WHERE `name`=?")) {
                preparedStatement.setString(1, getGson().toJson(repeatingMilestone));
                preparedStatement.setString(2, repeatingMilestone.getMilestoneName());
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while updating repeating milestone to database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * @param uuid
     * @param event
     * @param time
     * @return
     */
    @Override
    public CompletableFuture<Boolean> addPlaytimeHistory(UUID uuid, Event event, int time) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection.prepareStatement(
                    "INSERT INTO " + getTableName("playtime_history") + " (`uuid`, `time`, `date`) VALUES (?, ?, ?)")) {
                preparedStatement.setString(1, uuid.toString());
                preparedStatement.setInt(2, time);
                preparedStatement.setDate(4, new Date(new java.util.Date().getTime()));
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        });
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/storage/types/SqlLite.java">
package nl.thedutchruben.playtime.core.storage.types;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.Settings;
import nl.thedutchruben.playtime.core.objects.Milestone;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import nl.thedutchruben.playtime.core.objects.RepeatingMilestone;
import nl.thedutchruben.playtime.core.storage.SqlStatements;
import nl.thedutchruben.playtime.core.storage.Storage;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;
import java.util.concurrent.CompletableFuture;

public class SqlLite extends Storage {
    private HikariDataSource ds;
    private Connection connection;

    /**
     * Get the name of the storage type
     *
     * @return The name of the storage type
     */
    @Override
    public String getName() {
        return "sqllite";
    }

    /**
     * Setup the storage such as the database connection
     */
    @Override
    public boolean setup() {
        HikariConfig config = getHikariConfig();
        ds = new HikariDataSource(config);

        try {
            this.connection = ds.getConnection();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        for (String statement : SqlStatements.getStatements(Settings.STORAGE_MYSQL_PREFIX.getValueAsString(), false)) {
            try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
                preparedStatement.executeUpdate();
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while creating table in database: " + sqlException.getMessage());
            }
        }
        return false;
    }

    private static HikariConfig getHikariConfig() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:sqlite:" + Playtime.getPlugin().getDataFolder().getAbsolutePath() + "/playtime.db");
        config.setConnectionTestQuery("SELECT 1");
        config.addDataSourceProperty("cachePrepStmts", true);
        config.addDataSourceProperty("prepStmtCacheSize", "250");
        config.addDataSourceProperty("prepStmtCacheSwlLimit", "2048");
        config.setPoolName("PlaytimePool");
        config.setIdleTimeout(10000);
        config.setMaxLifetime(30000);
        config.setValidationTimeout(30000);
        config.setMaximumPoolSize(100);
        config.setMinimumIdle(10);
        config.setAllowPoolSuspension(false);
        config.setThreadFactory(r -> {
            Thread thread = new Thread(r);
            thread.setName("Playtime-Database-Thread-" + thread.getId());
            return thread;
        });
        return config;
    }

    /**
     * Stops the storage such things as the database connection
     */
    @Override
    public void stop() {
        try {
            this.connection.close();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        ds.close();
    }

    /**
     * Load the user from the storage
     *
     * @param uuid The uuid of the player
     * @return The playtime user
     */
    @Override
    public CompletableFuture<PlaytimeUser> loadUser(UUID uuid) {
        return CompletableFuture.supplyAsync(() -> {

            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("SELECT * FROM `playtime` WHERE `uuid` = ?")) {
                preparedStatement.setString(1, uuid.toString());
                try (ResultSet resultSet = preparedStatement.executeQuery()) {
                    if (resultSet.next()) {
                        return new PlaytimeUser(uuid.toString(), resultSet.getString("name"), resultSet.getLong("time"));
                    }
                }
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while loading user from database: " + sqlException.getMessage());
            }
            return null;
        });
    }

    /**
     * Load user loaded by name
     *
     * @param name
     * @return
     */
    @Override
    public CompletableFuture<PlaytimeUser> loadUserByName(String name) {
        return CompletableFuture.supplyAsync(() -> {

            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("SELECT * FROM `playtime` WHERE `name` = ?")) {
                preparedStatement.setString(1, name);
                try (ResultSet resultSet = preparedStatement.executeQuery()) {
                    if (resultSet.next()) {
                        return new PlaytimeUser(resultSet.getString("uuid"), resultSet.getString("name"), resultSet.getLong("time"));
                    }
                }
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while loading user from database: " + sqlException.getMessage());
            }
            return null;
        });
    }

    /**
     * Save the user to the storage
     *
     * @param playtimeUser The playtime user
     * @return If the user is saved
     */
    @Override
    public CompletableFuture<Boolean> saveUser(PlaytimeUser playtimeUser) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("UPDATE `playtime` SET `name` = ?, `time` = ? WHERE `uuid` = ?")) {
                preparedStatement.setString(1, playtimeUser.getName());
                preparedStatement.setFloat(2, playtimeUser.getTime());
                preparedStatement.setString(3, playtimeUser.getUUID().toString());
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while saving user to database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Create the user
     *
     * @param playtimeUser
     * @return
     */
    @Override
    public CompletableFuture<Boolean> createUser(PlaytimeUser playtimeUser) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("INSERT INTO `playtime` (`uuid`, `name`, `time`) VALUES (?, ?, ?)")) {
                preparedStatement.setString(1, playtimeUser.getUUID().toString());
                preparedStatement.setString(2, playtimeUser.getName());
                preparedStatement.setFloat(3, playtimeUser.getTime());
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while creating user in database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Get the top users
     *
     * @param amount The amount of users
     * @param skip   The amount of users to skip
     * @return The list of users
     */
    @Override
    public CompletableFuture<List<PlaytimeUser>> getTopUsers(int amount, int skip) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("SELECT * FROM `playtime` ORDER BY `time` DESC LIMIT ? OFFSET ?")) {
                preparedStatement.setInt(1, amount);
                preparedStatement.setInt(2, skip);
                try (ResultSet resultSet = preparedStatement.executeQuery()) {
                    List<PlaytimeUser> playtimeUsers = new ArrayList<>();
                    while (resultSet.next()) {
                        playtimeUsers.add(new PlaytimeUser(resultSet.getString("uuid"), resultSet.getString("name"), resultSet.getLong("time")));
                    }
                    return playtimeUsers;
                }
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while getting top users from database: " + sqlException.getMessage());
            }
            return null;
        });
    }

    /**
     * Get the top user
     *
     * @param place The place of the user
     * @return The user
     */
    @Override
    public CompletableFuture<PlaytimeUser> getTopUser(int place) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("SELECT * FROM `playtime` ORDER BY `time` DESC LIMIT 1 OFFSET ?")) {
                preparedStatement.setInt(1, place);
                try (ResultSet resultSet = preparedStatement.executeQuery()) {
                    if (resultSet.next()) {
                        return new PlaytimeUser(resultSet.getString("uuid"), resultSet.getString("name"), resultSet.getLong("time"));
                    }
                }
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while getting top user from database: " + sqlException.getMessage());
            }
            return null;
        });
    }

    /**
     * Get the milestones
     *
     * @return The list of milestones
     */
    @Override
    public CompletableFuture<List<Milestone>> getMilestones() {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("SELECT * FROM `milestones`")) {
                try (ResultSet resultSet = preparedStatement.executeQuery()) {
                    List<Milestone> milestones = new ArrayList<>();
                    while (resultSet.next()) {
                        milestones.add(getGson().fromJson(resultSet.getString("data"), Milestone.class));
                    }
                    return milestones;
                }
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while getting milestones from database: " + sqlException.getMessage());
            }
            return null;
        });
    }

    /**
     * Save the milestone
     *
     * @param milestone The milestone to save
     * @return If the milestone is saved
     */
    @Override
    public CompletableFuture<Boolean> saveMilestone(Milestone milestone) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("INSERT INTO `milestones`(`name`, `data`) VALUES (?,?)")) {
                preparedStatement.setString(1, milestone.getMilestoneName());
                preparedStatement.setString(2, getGson().toJson(milestone));
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while saving milestone to database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Delete the milestone
     *
     * @param milestone The milestone to delete
     * @return If the milestone is deleted
     */
    @Override
    public CompletableFuture<Boolean> deleteMilestone(Milestone milestone) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("DELETE FROM `milestones` WHERE `name`=?")) {
                preparedStatement.setString(1, milestone.getMilestoneName());
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while deleting milestone from database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Update the milestone
     *
     * @param milestone The milestone to update
     * @return If the milestone is updated
     */
    @Override
    public CompletableFuture<Boolean> updateMilestone(Milestone milestone) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("UPDATE `milestones` SET `data`=? WHERE `name`=?")) {
                preparedStatement.setString(1, getGson().toJson(milestone));
                preparedStatement.setString(2, milestone.getMilestoneName());
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while updating milestone to database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Get the repeating milestones
     *
     * @return The list of repeating milestones
     */
    @Override
    public CompletableFuture<List<RepeatingMilestone>> getRepeatingMilestones() {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("SELECT * FROM `repeating_milestones`")) {
                try (ResultSet resultSet = preparedStatement.executeQuery()) {
                    List<RepeatingMilestone> repeatingMilestones = new ArrayList<>();
                    while (resultSet.next()) {
                        repeatingMilestones.add(getGson().fromJson(resultSet.getString("data"), RepeatingMilestone.class));
                    }
                    return repeatingMilestones;
                }
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while getting repeating milestones from database: " + sqlException.getMessage());
            }
            return null;
        });
    }

    /**
     * Save the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to save
     * @return If the repeating milestone is saved
     */
    @Override
    public CompletableFuture<Boolean> saveRepeatingMilestone(RepeatingMilestone repeatingMilestone) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("INSERT INTO `repeating_milestones`(`name`, `data`) VALUES (?,?)")) {
                preparedStatement.setString(1, repeatingMilestone.getMilestoneName());
                preparedStatement.setString(2, getGson().toJson(repeatingMilestone));
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while saving repeating milestone to database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Delete the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to delete
     * @return If the repeating milestone is deleted
     */
    @Override
    public CompletableFuture<Boolean> deleteRepeatingMilestone(RepeatingMilestone repeatingMilestone) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("DELETE FROM `repeating_milestones` WHERE `name`=?")) {
                preparedStatement.setString(1, repeatingMilestone.getMilestoneName());
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while deleting repeating milestone from database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * Update the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to update
     * @return If the repeating milestone is updated
     */
    @Override
    public CompletableFuture<Boolean> updateRepeatingMilestone(RepeatingMilestone repeatingMilestone) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection
                    .prepareStatement("UPDATE `repeating_milestones` SET `data`=? WHERE `name`=?")) {
                preparedStatement.setString(1, getGson().toJson(repeatingMilestone));
                preparedStatement.setString(2, repeatingMilestone.getMilestoneName());
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException sqlException) {
                Playtime.getPlugin().getLogger().severe("Error while updating repeating milestone to database: " + sqlException.getMessage());
            }
            return false;
        });
    }

    /**
     * @param uuid
     * @param event
     * @param time
     * @return
     */
    @Override
    public CompletableFuture<Boolean> addPlaytimeHistory(UUID uuid, Event event, int time) {
        return CompletableFuture.supplyAsync(() -> {
            try (PreparedStatement preparedStatement = connection.prepareStatement(
                    "INSERT INTO playtime_history (`uuid`, `time`, `date`) VALUES (?, ?, ?)")) {
                preparedStatement.setString(1, uuid.toString());
                preparedStatement.setInt(2, time);
                preparedStatement.setDate(4, new Date(new java.util.Date().getTime()));
                preparedStatement.executeUpdate();
                return true;
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        });
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/storage/types/SqlLiteTest.java">
package nl.thedutchruben.playtime.core.storage.types;

import nl.thedutchruben.playtime.core.objects.Milestone;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import nl.thedutchruben.playtime.core.objects.RepeatingMilestone;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.MockedStatic;

import java.io.File;
import java.nio.file.Path;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.ExecutionException;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class SqlLiteTest {

    private SqlLite sqlLite;
    private final UUID testUuid = UUID.randomUUID();
    private final String testName = "TestPlayer";

    @TempDir
    Path tempDir;

    @BeforeEach
    void setUp() {
        // Set system property to use temp directory for database
        System.setProperty("playtime.dbfile", tempDir.resolve("playtime.db").toString());

        sqlLite = new SqlLite();
        sqlLite.setup();
    }

    @AfterEach
    void tearDown() {
        sqlLite.stop();
        System.clearProperty("playtime.dbfile");
    }

    @Test
    void testCreateAndLoadUser() throws ExecutionException, InterruptedException {
        // Create a user
        PlaytimeUser user = new PlaytimeUser(testUuid.toString(), testName, 3600000); // 1 hour playtime
        assertTrue(sqlLite.createUser(user).get());

        // Load the user and verify
        PlaytimeUser loadedUser = sqlLite.loadUser(testUuid).get();
        assertNotNull(loadedUser);
        assertEquals(testUuid.toString(), loadedUser.getUUID().toString());
        assertEquals(testName, loadedUser.getName());
        assertEquals(3600000, loadedUser.getTime());
    }

    @Test
    void testSaveUser() throws ExecutionException, InterruptedException {
        // Create a user
        PlaytimeUser user = new PlaytimeUser(testUuid.toString(), testName, 0);
        assertTrue(sqlLite.createUser(user).get());

        // Update playtime
        user.setPlaytime(7200000); // 2 hours
        assertTrue(sqlLite.saveUser(user).get());

        // Load and verify
        PlaytimeUser loadedUser = sqlLite.loadUser(testUuid).get();
        assertEquals(7200000, loadedUser.getTime());
    }

    @Test
    void testCreateAndGetMilestone() throws ExecutionException, InterruptedException {
        // Create a milestone
        Milestone milestone = new Milestone();
        milestone.setMilestoneName("TestMilestone");
        milestone.setOnlineTime(3600); // 1 hour
        milestone.addCommand("give %playername% diamond 1");
        milestone.addMessage("Congratulations!");

        assertTrue(sqlLite.saveMilestone(milestone).get());

        // Get all milestones
        List<Milestone> milestones = sqlLite.getMilestones().get();
        assertEquals(1, milestones.size());

        Milestone loadedMilestone = milestones.get(0);
        assertEquals("TestMilestone", loadedMilestone.getMilestoneName());
        assertEquals(3600, loadedMilestone.getOnlineTime());
        assertEquals(1, loadedMilestone.getCommands().size());
        assertEquals(1, loadedMilestone.getMessages().size());
    }

    @Test
    void testDeleteMilestone() throws ExecutionException, InterruptedException {
        // Create a milestone
        Milestone milestone = new Milestone();
        milestone.setMilestoneName("DeleteTest");
        milestone.setOnlineTime(3600);

        assertTrue(sqlLite.saveMilestone(milestone).get());

        // Delete the milestone
        assertTrue(sqlLite.deleteMilestone(milestone).get());

        // Verify it's gone
        List<Milestone> milestones = sqlLite.getMilestones().get();
        assertEquals(0, milestones.size());
    }

    @Test
    void testGetTopUsers() throws ExecutionException, InterruptedException {
        // Create multiple users with different playtimes
        UUID uuid1 = UUID.randomUUID();
        UUID uuid2 = UUID.randomUUID();
        UUID uuid3 = UUID.randomUUID();

        PlaytimeUser user1 = new PlaytimeUser(uuid1.toString(), "Player1", 10000);
        PlaytimeUser user2 = new PlaytimeUser(uuid2.toString(), "Player2", 20000);
        PlaytimeUser user3 = new PlaytimeUser(uuid3.toString(), "Player3", 30000);

        sqlLite.createUser(user1).get();
        sqlLite.createUser(user2).get();
        sqlLite.createUser(user3).get();

        // Get top 2 users
        List<PlaytimeUser> topUsers = sqlLite.getTopUsers(2, 0).get();
        assertEquals(2, topUsers.size());

        // Verify they're in order
        assertEquals(user3.getName(), topUsers.get(0).getName());
        assertEquals(user2.getName(), topUsers.get(1).getName());
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/storage/types/Yaml.java">
package nl.thedutchruben.playtime.core.storage.types;

import com.google.gson.Gson;
import nl.thedutchruben.mccore.utils.GsonUtil;
import nl.thedutchruben.mccore.utils.config.FileManager;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.objects.Milestone;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import nl.thedutchruben.playtime.core.objects.RepeatingMilestone;
import nl.thedutchruben.playtime.core.storage.Storage;
import org.bukkit.Bukkit;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.CompletableFuture;

public class Yaml extends Storage {
    private final Gson gson;

    public Yaml() {
        this.gson = GsonUtil.createGson();
    }

    /**
     * Get the name of the storage type
     *
     * @return The name of the storage type
     */
    @Override
    public String getName() {
        return "Yaml";
    }

    /**
     * Set up the storage such as the database connection
     */
    @Override
    public boolean setup() {

        return true;
    }

    /**
     * Stops the storage such things as the database connection
     */
    @Override
    public void stop() {

    }

    /**
     * Load the user from the storage
     *
     * @param uuid The uuid of the player
     * @return The playtime user
     */
    @Override
    public CompletableFuture<PlaytimeUser> loadUser(UUID uuid) {
        return CompletableFuture.supplyAsync(() -> {
            long playtime = Playtime.getInstance().getFileManager().getConfig("players/" + uuid + ".yaml").get().getLong("onlinetime", 0);
            return new PlaytimeUser(uuid.toString(), Objects.requireNonNull(Bukkit.getPlayer(uuid)).getName(), playtime);
        });
    }

    /**
     * Load user loaded by name
     *
     * @param name
     * @return
     */
    @Override
    public CompletableFuture<PlaytimeUser> loadUserByName(String name) {
        return CompletableFuture.supplyAsync(() -> {
            Player player = Bukkit.getPlayer(name);
            if (player != null) {
                long playtime = Playtime.getInstance().getFileManager().getConfig("players/" + player.getUniqueId() + ".yaml").get().getLong("onlinetime", 0);
                return new PlaytimeUser(player.getUniqueId().toString(), player.getName(), playtime);
            }
            return null;
        });
    }

    /**
     * Save the user to the storage
     *
     * @param playtimeUser The playtime user
     * @return If the user is saved
     */
    @Override
    public CompletableFuture<Boolean> saveUser(PlaytimeUser playtimeUser) {
        return CompletableFuture.supplyAsync(() -> {
            FileManager.Config config = Playtime.getInstance().getFileManager().getConfig("players/" + playtimeUser.getUUID().toString() + ".yaml");
            config.set("onlinetime", playtimeUser.getTime());
            config.save();
            return true;
        });
    }

    /**
     * Create the user
     *
     * @param playtimeUser
     * @return
     */
    @Override
    public CompletableFuture<Boolean> createUser(PlaytimeUser playtimeUser) {
        return CompletableFuture.supplyAsync(() -> {
            FileManager.Config config = Playtime.getInstance().getFileManager().getConfig("players/" + playtimeUser.getUUID().toString() + ".yaml");
            config.set("onlinetime", playtimeUser.getTime());
            config.save();
            return true;
        });
    }

    /**
     * Get the top users
     *
     * @param amount The amount of users
     * @param skip   The amount of users to skip
     * @return The list of users
     */
    @Override
    public CompletableFuture<List<PlaytimeUser>> getTopUsers(int amount, int skip) {
        return CompletableFuture.supplyAsync(() -> {
            List<PlaytimeUser> data = getTopUsersData().join();
            if (data.size() < amount + skip) {
                return data;
            }

            return data.subList(skip, amount + skip);
        });
    }

    public CompletableFuture<List<PlaytimeUser>> getTopUsersData() {
        return CompletableFuture.supplyAsync(() -> {
            List<PlaytimeUser> playtimeUsers = new ArrayList<>();
            File folder = new File(Playtime.getPlugin().getDataFolder(), "players");
            File[] files = folder.listFiles();
            if (files != null) {
                for (File file : files) {
                    YamlConfiguration yamlConfiguration = YamlConfiguration.loadConfiguration(file);
                    String uuid = file.getName().replace(".yaml", "");
                    long time = yamlConfiguration.getLong("onlinetime", 0);
                    playtimeUsers.add(new PlaytimeUser(uuid, Bukkit.getOfflinePlayer(UUID.fromString(uuid)).getName(), time));
                }
            }
            playtimeUsers.sort((o1, o2) -> {
                if (o1.getTime() > o2.getTime()) {
                    return -1;
                } else if (o1.getTime() < o2.getTime()) {
                    return 1;
                }
                return 0;
            });
            return playtimeUsers;
        });
    }

    /**
     * Get the top user
     *
     * @param place The place of the user
     * @return The user
     */
    @Override
    public CompletableFuture<PlaytimeUser> getTopUser(int place) {
        return CompletableFuture.supplyAsync(() -> {
            List<PlaytimeUser> data = getTopUsersData().join();
            if (data.size() < place) {
                return null;
            }
            return data.get(place - 1);
        });
    }

    /**
     * Get the milestones
     *
     * @return The list of milestones
     */
    @Override
    public CompletableFuture<List<Milestone>> getMilestones() {
        return CompletableFuture.supplyAsync(() -> {
            List<Milestone> milestones = new ArrayList<>();
            File[] files = new File(Playtime.getPlugin().getDataFolder(), "milestones/").listFiles();

            if (files == null) {
                return milestones;
            }

            for (final File fileEntry : files) {
                YamlConfiguration config = Playtime.getInstance().getFileManager()
                        .getConfig("milestones/" + fileEntry.getName()).get();
                if (config != null) {
                    milestones.add(this.gson.fromJson(config.getString("data"), Milestone.class));
                }
            }
            return milestones;
        });
    }

    /**
     * Save the milestone
     *
     * @param milestone The milestone to save
     * @return If the milestone is saved
     */
    @Override
    public CompletableFuture<Boolean> saveMilestone(Milestone milestone) {
        return CompletableFuture.supplyAsync(() -> {
            Playtime.getInstance().getFileManager().getConfig("milestones/" + milestone.getMilestoneName() + ".yaml")
                    .get().set("data", this.gson.toJson(milestone, Milestone.class));
            Playtime.getInstance().getFileManager().getConfig("milestones/" + milestone.getMilestoneName() + ".yaml")
                    .save();
            return true;
        });

    }

    /**
     * Delete the milestone
     *
     * @param milestone The milestone to delete
     * @return If the milestone is deleted
     */
    @Override
    public CompletableFuture<Boolean> deleteMilestone(Milestone milestone) {
        return CompletableFuture.supplyAsync(() -> {
            Playtime.getInstance().getFileManager()
                    .getConfig("milestones/" + milestone.getMilestoneName() + ".yaml").file.delete();
            return true;
        });
    }

    /**
     * Update the milestone
     *
     * @param milestone The milestone to update
     * @return If the milestone is updated
     */
    @Override
    public CompletableFuture<Boolean> updateMilestone(Milestone milestone) {
        return saveMilestone(milestone);
    }

    /**
     * Get the repeating milestones
     *
     * @return The list of repeating milestones
     */
    @Override
    public CompletableFuture<List<RepeatingMilestone>> getRepeatingMilestones() {
        return CompletableFuture.supplyAsync(() -> {
            List<RepeatingMilestone> milestones = new ArrayList<>();
            File[] files = new File(Playtime.getPlugin().getDataFolder(), "repeatingmilestones/").listFiles();

            if (files == null) {
                return milestones;
            }

            for (final File fileEntry : files) {
                YamlConfiguration config = Playtime.getInstance().getFileManager()
                        .getConfig("repeatingmilestones/" + fileEntry.getName()).get();
                if (config != null) {
                    milestones.add(this.gson.fromJson(config.getString("data"), RepeatingMilestone.class));
                }
            }
            return milestones;
        });
    }

    /**
     * Save the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to save
     * @return If the repeating milestone is saved
     */
    @Override
    public CompletableFuture<Boolean> saveRepeatingMilestone(RepeatingMilestone repeatingMilestone) {
        return CompletableFuture.supplyAsync(() -> {
            Playtime.getInstance().getFileManager()
                    .getConfig("repeatingmilestones/" + repeatingMilestone.getMilestoneName() + ".yaml").get()
                    .set("data", this.gson.toJson(repeatingMilestone, RepeatingMilestone.class));
            Playtime.getInstance().getFileManager()
                    .getConfig("repeatingmilestones/" + repeatingMilestone.getMilestoneName() + ".yaml").save();
            return true;
        });
    }

    /**
     * Delete the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to delete
     * @return If the repeating milestone is deleted
     */
    @Override
    public CompletableFuture<Boolean> deleteRepeatingMilestone(RepeatingMilestone repeatingMilestone) {
        return CompletableFuture.supplyAsync(() -> {
            Playtime.getInstance().getFileManager()
                    .getConfig("repeatingmilestones/" + repeatingMilestone.getMilestoneName() + ".yaml").file.delete();
            return true;
        });
    }

    /**
     * Update the repeating milestone
     *
     * @param repeatingMilestone The repeating milestone to update
     * @return If the repeating milestone is updated
     */
    @Override
    public CompletableFuture<Boolean> updateRepeatingMilestone(RepeatingMilestone repeatingMilestone) {
        return saveRepeatingMilestone(repeatingMilestone);
    }

    /**
     * @param uuid
     * @param event
     * @param time
     * @return
     */
    @Override
    public CompletableFuture<Boolean> addPlaytimeHistory(UUID uuid, Event event, int time) {
        return CompletableFuture.supplyAsync(() -> {
            FileManager.Config config = Playtime.getInstance().getFileManager().getConfig("players/history/" + uuid + ".yaml");
            List<String> history = config.get().getStringList("history");

            history.add("UUID:" + uuid + "|EVENT:" + event + "|TIME:" + time + "|DATE" + new Date());

            config.set("history", history);
            config.save();
            return true;
        });
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/core/translations/Messages.java">
package nl.thedutchruben.playtime.core.translations;

import lombok.Getter;
import nl.thedutchruben.mccore.utils.message.MessageUtil;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.utils.Replacement;
import org.bukkit.ChatColor;
import org.bukkit.configuration.file.YamlConfiguration;

import java.util.HashMap;
import java.util.Map;

public enum Messages {

    ONLY_PLAYER_COMMAND("only.player.command", "&cThis is a player only command!"),

    PLAYTIME_INFO_OWN("command.playtime.time_message", "&8[&6PlayTime&8] &7Your playtime is &6%D% &7day(s) &6%H% &7hour(s) &6%M% &7minute(s) &6%S% &7second(s)"),
    PLAYTIME_INFO_OTHER("command.playtime.user_time_message", "&8[&6PlayTime&8] &7%NAME% 's playtime is &6%D% &7day(s) &6%H% &7hour(s) &6%M% &7minute(s) &6%S% &7second(s)"),
    PLAYER_RESET_CONFIRM("command.playtime.reset_time_confirm", "&cUser time reset!"),
    TIME_ADDED("command.playtime.time_added", "&aYou have successfully added playtime to <player>"),
    TIME_REMOVED("command.playtime.time_removed", "&aYou have successfully removed playtime from <player>"),
    PLAYTIME_IMPORTED("command.playtime.imported", "&aYou have successfully imported <count> players!"),
    PLAYER_DOES_NOT_EXIST("command.playtime.player_does_not_exist", "&cThe player does not exist!"),

    MILESTONE_CREATED("command.milestone.created", "&aThe milestone is created!"),
    MILESTONE_ITEM_ADDED("command.milestone.item_added", "&aYou added successfully an item to the milestone!"),
    MILESTONE_COMMAND_ADDED("command.milestone.command_added", "&aYou added successfully a command to the milestone!"),
    MILESTONE_FIREWORK_TOGGLED("command.milestone.firework_toggled", "&aYou <state> the firework for the milestone"),
    MILESTONE_SET_FIREWORK_AMOUNT("command.milestone.set_firework_amount", "&aYou set the firework amount to <amount>"),
    MILESTONE_SET_FIREWORK_DELAY("command.milestone.set_firework_delay", "&aYou set the firework delay to <amount>"),
    MILESTONE_REMOVED("command.milestone.removed", "&aYou have successfully removed the milestone!"),
    MILESTONE_COMMAND_REMOVED("command.milestone.command_removed", "&aYou removed a command from the milestone!"),
    MILESTONE_LIST("command.milestone.list", "%MILESTONE_NAME% Time: Days: %D% Hours: %H% ,Minute's: %M% ,Seconds's: %S%"),
    MILESTONE_INFO("command.milestone.info", "%MILESTONE_NAME% Time: Days: %D% Hours: %H% ,Minute's: %M% ,Seconds's: %S% Rewards: Commands(%REWARD_COMMAND_COUNT%): %REWARD_COMMAND% Items(%REWARD_ITEMS_COUNT%): %REWARD_ITEMS%"),
    MILESTONE_MESSAGE_ADDED("command.milestone.message_added", "&aYou have successfully added a message to a milestone!"),
    MILESTONE_MESSAGE_REMOVED("command.milestone.message_removed", "&aYou have removed a message from a milestone!"),
    MILESTONE_REWARDS_APPLIED("command.milestone.rewards_applied", "&aYou have successfully applied the rewards!"),
    MILESTONE_DOES_NOT_EXIST("command.milestone.milestone_does_not_exist", "&cThe milestone does not exist!"),
    MILESTONE_COULD_NOT_BE_CREATED("command.milestone.could_not_be_created", "&cThe milestone could not be created!"),

    REPEATING_MILESTONE_REMOVED("command.repeating_milestone.removed", "&aYou have successfully removed the repeating milestone!"),
    REPEATING_MILESTONE_DOES_NOT_EXIST("command.repeating_milestone.does_not_exist", "&cThe repeating milestone does not exist!"),
    REPEATING_MILESTONE_COULD_NOT_BE_CREATED("command.repeating_milestone.could_not_be_created", "&cThe repeating milestone could not be created!"),
    REPEATING_MILESTONE_CREATED("command.repeating_milestone.created", "&aYou have successfully created a repeating milestone!"),
    REPEATING_MILESTONE_DELETED("command.repeating_milestone.deleted", "&aYou have successfully deleted a repeating milestone!"),
    REPEATING_MILESTONE_ITEM_ADDED("command.repeating_milestone.item_added", "&aYou have successfully added an item to the repeating milestone!"),
    REPEATING_MILESTONE_ITEM_REMOVED("command.repeating_milestone.item_removed", "&aYou have successfully removed an item from the repeating milestone!"),
    REPEATING_MILESTONE_COMMAND_ADDED("command.repeating_milestone.command_added", "&aYou have successfully added a command to the repeating milestone!"),
    REPEATING_MILESTONE_FIREWORK_TOGGLED("command.repeating_milestone.firework_toggled", "&aYou <state> the firework for the repeating milestone"),
    REPEATING_MILESTONE_SET_FIREWORK_AMOUNT("command.repeating_milestone.set_firework_amount", "&aYou set the firework amount to <amount>"),
    REPEATING_MILESTONE_SET_FIREWORK_DELAY("command.repeating_milestone.set_firework_delay", "&aYou set the firework delay to <amount>"),
    REPEATING_MILESTONE_MESSAGE_ADDED("command.repeating_milestone.message_added", "&aYou have successfully added a message to a repeating milestone!"),
    REPEATING_MILESTONE_MESSAGE_REMOVED("command.repeating_milestone.message_removed", "&aYou have removed a message from a repeating milestone!"),
    REPEATING_MILESTONE_LIST("command.repeating_milestone.list", "%REPEATING_MILESTONE_NAME% Time: Days: %D% Hours: %H% ,Minute's: %M% Seconds's: %S%"),
    ;

    @Getter
    private static final Map<String, String> messages = new HashMap<>();
    private final String path;
    private final String fallBack;

    Messages(String path, String fallBack) {
        this.path = path;
        this.fallBack = fallBack;
    }

    /**
     * Set up the default messages
     */
    public static void setupDefaults() {
        YamlConfiguration file = Playtime.getInstance().getFileManager().getConfig("translations.yml").get();
        for (Messages value : Messages.values()) {
            if (!file.contains(value.path)) {
                file.set(value.path, value.fallBack);
            }
        }

        Playtime.getInstance().getFileManager().getConfig("lang/translations.yml").save();
    }

    /**
     * Get the message from the path
     *
     * @param replacements The replacements to replace in the message
     * @return The message
     */
    public String getMessage(Replacement... replacements) {
        String message = messages.computeIfAbsent(path, a -> {
            YamlConfiguration file = Playtime.getInstance().getFileManager().getConfig("lang/translations.yml").get();
            return file.getString(path, fallBack);
        });
        message = MessageUtil.translateHexColorCodes("<", ">", ChatColor.translateAlternateColorCodes('&', message));
        for (Replacement replacement : replacements) {
            message = message.replace(replacement.getFrom(), replacement.getTo());
        }
        return message;
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/extentions/BStatsExtension.java">
package nl.thedutchruben.playtime.extentions;

import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.Settings;
import org.bstats.bukkit.Metrics;
import org.bstats.charts.SimplePie;
import org.bukkit.Bukkit;
import org.bukkit.plugin.Plugin;
import org.bukkit.plugin.java.JavaPlugin;

import java.io.InputStream;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class BStatsExtension {

    public void startBStats(JavaPlugin plugin) {
        Metrics metrics = new Metrics(plugin, 9404);

        String[] pluginNames = {"PlaceholderAPI", "HolographicDisplay", "DecentHolograms", "WorldGuard", "JoinAndQuitMessages"};
        for (String pluginName : pluginNames) {
            Plugin pl = Bukkit.getPluginManager().getPlugin(pluginName);
            if (pl != null) {
                metrics.addCustomChart(new SimplePie("addons_use", () -> pluginName));
            }
        }

        try (InputStream inputStream = plugin.getClass().getResourceAsStream("/plugin.yml")) {
            byte[] buffer = inputStream != null ? inputStream.readAllBytes() : new byte[0];
            String pluginYml = new String(buffer);

            Matcher matcher = Pattern.compile("downloadSource:\\s*'([^']+)'").matcher(pluginYml);
            String downloadSource = matcher.find() ? matcher.group(1) : "unknown";
            metrics.addCustomChart(new SimplePie("download_source", () -> downloadSource));
        } catch (Exception e) {
            plugin.getLogger().warning(e.getMessage());
        }

        metrics.addCustomChart(new SimplePie("bungeecord", () -> String.valueOf(plugin.getServer().spigot().getConfig().getBoolean("settings.bungeecord"))));
        metrics.addCustomChart(new SimplePie("database_type", () -> Playtime.getInstance().getStorage().getName()));
        metrics.addCustomChart(new SimplePie("update_checker", () -> String.valueOf(Settings.UPDATE_CHECK.getValue())));
        metrics.addCustomChart(new SimplePie("uses_milestones", () -> String.valueOf(Playtime.getInstance().getMilestones().size() > 1)));
        metrics.addCustomChart(new SimplePie("uses_repeating_milestones", () -> String.valueOf(Playtime.getInstance().getRepeatingMilestones().size() > 1)));
        metrics.addCustomChart(new SimplePie("count_afk_time", () -> String.valueOf(Settings.AFK_COUNT_TIME.getValue())));
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/extentions/PlaceholderAPIExtension.java">
package nl.thedutchruben.playtime.extentions;

import me.clip.placeholderapi.expansion.PlaceholderExpansion;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import nl.thedutchruben.playtime.core.translations.Messages;
import nl.thedutchruben.playtime.utils.Replacement;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.logging.Level;

public class PlaceholderAPIExtension extends PlaceholderExpansion {

    @Override
    public String getIdentifier() {
        return "tdrplaytime";
    }

    @Override
    public String getAuthor() {
        return Playtime.getPlugin().getDescription().getAuthors().toString();
    }

    @Override
    public String getVersion() {
        return Playtime.getPlugin().getDescription().getVersion();
    }

    @Override
    public List<String> getPlaceholders() {
        List<String> placeholders = new ArrayList<>();
        placeholders.add("%tdrplaytime_time%");
        placeholders.add("%tdrplaytime_time_days_number%");
        placeholders.add("%tdrplaytime_time_hour_number%");
        placeholders.add("%tdrplaytime_time_minutes_number%");
        placeholders.add("%tdrplaytime_time_seconds_number%");

        for (int i = 1; i <= 10; i++) {
            placeholders.add("%tdrplaytime_top_names_" + i + "%");
            placeholders.add("%tdrplaytime_top_time_" + i + "_days%");
            placeholders.add("%tdrplaytime_top_time_" + i + "_hours%");
            placeholders.add("%tdrplaytime_top_time_" + i + "_minutes%");
            placeholders.add("%tdrplaytime_top_time_" + i + "_seconds%");
        }

        return placeholders;
    }

    @Override
    public String onPlaceholderRequest(Player player, String params) {
        String dummyProofParams = params.toLowerCase().replace('-', '_');
        PlaytimeUser user = Playtime.getInstance().getPlaytimeUsers().get(player.getUniqueId());

        if (dummyProofParams.equals("time")) {
            return Messages.PLAYTIME_INFO_OWN.getMessage(
                    new Replacement("%D%", String.valueOf(user.translateTime()[0])),
                    new Replacement("%H%", String.valueOf(user.translateTime()[1])),
                    new Replacement("%M%", String.valueOf(user.translateTime()[2])),
                    new Replacement("%S%", String.valueOf(user.translateTime()[3]))
            );
        }

        if (dummyProofParams.contains("days_number")) {
            return String.valueOf(user.translateTime()[0]);
        } else if (dummyProofParams.contains("hour_number")) {
            return String.valueOf(user.translateTime()[1]);
        } else if (dummyProofParams.contains("minutes_number")) {
            return String.valueOf(user.translateTime()[2]);
        } else if (dummyProofParams.contains("seconds_number")) {
            return String.valueOf(user.translateTime()[3]);
        }

        if (dummyProofParams.contains("top_names_")) {
            int placeNumber = parsePlaceNumber(dummyProofParams);
            return getTopUserName(placeNumber);
        }

        if (dummyProofParams.contains("top_time_")) {
            int placeNumber = parsePlaceNumber(dummyProofParams);
            return getTopUserTime(dummyProofParams, placeNumber);
        }

        return super.onPlaceholderRequest(player, params);
    }

    private int parsePlaceNumber(String params) {
        try {
            String[] parts = params.split("_");
            return Math.max(Integer.parseInt(parts[parts.length - 1]), 1);
        } catch (NumberFormatException e) {
            Bukkit.getLogger().log(Level.WARNING, "Wrong number format");
            return 1;
        }
    }

    private String getTopUserName(int placeNumber) {
        try {
            PlaytimeUser playtimeUser = Playtime.getInstance().getStorage().getTopUser(placeNumber - 1).get();
            return playtimeUser != null ? playtimeUser.getName() : "No user found";
        } catch (InterruptedException | ExecutionException e) {
            throw new RuntimeException(e);
        }
    }

    private String getTopUserTime(String params, int placeNumber) {
        try {
            PlaytimeUser playtimeUser = Playtime.getInstance().getStorage().getTopUser(placeNumber - 1).get();
            if (playtimeUser != null) {
                if (Bukkit.getPlayer(playtimeUser.getUUID()) != null) {
                    playtimeUser = Playtime.getInstance().getPlaytimeUser(playtimeUser.getUUID()).get();
                }
                if (params.endsWith("_days")) {
                    return String.valueOf(playtimeUser.translateTime()[0]);
                } else if (params.endsWith("_hours")) {
                    return String.valueOf(playtimeUser.translateTime()[1]);
                } else if (params.endsWith("_minutes")) {
                    return String.valueOf(playtimeUser.translateTime()[2]);
                } else if (params.endsWith("_seconds")) {
                    return String.valueOf(playtimeUser.translateTime()[3]);
                } else {
                    return String.valueOf(playtimeUser.getTime());
                }
            } else {
                return "0";
            }
        } catch (InterruptedException | ExecutionException e) {
            throw new RuntimeException(e);
        }
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/modules/milestones/commands/MileStoneCommand.java">
package nl.thedutchruben.playtime.modules.milestones.commands;

import net.md_5.bungee.api.chat.ClickEvent;
import net.md_5.bungee.api.chat.TextComponent;
import nl.thedutchruben.mccore.spigot.commands.Command;
import nl.thedutchruben.mccore.spigot.commands.Default;
import nl.thedutchruben.mccore.spigot.commands.SubCommand;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.events.milestone.MilestoneCreateEvent;
import nl.thedutchruben.playtime.core.events.milestone.MilestoneDeleteEvent;
import nl.thedutchruben.playtime.core.events.milestone.MilestoneUpdateEvent;
import nl.thedutchruben.playtime.core.objects.Milestone;
import nl.thedutchruben.playtime.core.translations.Messages;
import nl.thedutchruben.playtime.utils.Replacement;
import org.bukkit.Bukkit;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Command(command = "milestone", description = "Main milestone command", permission = "playtime.milestone", console = true)
public class MileStoneCommand {

    @SubCommand(
        subCommand = "create",
        description = "Create a new milestone",
        usage = "<name> <time>",
        permission = "playtime.milestone.create",
        console = true,
        minParams = 3,
        maxParams = 3)
    public void create(CommandSender commandSender, List<String> args) {
        Milestone milestone = new Milestone();
        milestone.setMilestoneName(args.get(1));
        long time = getTime(args.get(2));
        milestone.setOnlineTime(time);
        Playtime.getInstance().getStorage().saveMilestone(milestone).thenAcceptAsync(aBoolean -> {
            if (aBoolean) {
                commandSender.sendMessage(Messages.MILESTONE_CREATED.getMessage());
                Playtime.getInstance().getMilestones().add(milestone);
                Bukkit.getPluginManager().callEvent(new MilestoneCreateEvent(milestone));
            } else {
                commandSender.sendMessage(Messages.MILESTONE_COULD_NOT_BE_CREATED.getMessage());
            }
        });
    }

    @SubCommand(
        subCommand = "delete",
        description = "Delete a milestone",
        usage = "<milestone>",
        permission = "playtime.milestone.delete",
        minParams = 2,
        maxParams = 2,
        console = true
    )
    public void delete(CommandSender commandSender, List<String> args) {
        Milestone milestone = Milestone.getMilestone(args.get(1));
        if (milestone == null) {
            commandSender.sendMessage(Messages.MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        Playtime.getInstance().getStorage().deleteMilestone(milestone).thenAcceptAsync(aBoolean -> {
            if (aBoolean) {
                commandSender.sendMessage(Messages.MILESTONE_REMOVED.getMessage());
                Bukkit.getPluginManager().callEvent(new MilestoneDeleteEvent(milestone));
                Playtime.getInstance().getMilestones().removeIf(milestone1 -> milestone1.getMilestoneName().equals(milestone.getMilestoneName()));
            } else {
                commandSender.sendMessage(Messages.MILESTONE_DOES_NOT_EXIST.getMessage());
            }
        });
    }

    @Default
    @SubCommand(
        subCommand = "list",
        description = "List all milestones",
        permission = "playtime.milestone.list",
        console = true
    )
    public void list(CommandSender commandSender, List<String> args) {
        List<Milestone> milestones = Playtime.getInstance().getMilestones();
        commandSender.sendMessage("Milestones: ");
        for (Milestone milestone : milestones) {
            TextComponent message = new TextComponent(Messages.MILESTONE_LIST.getMessage(
                new Replacement("%MILESTONE_NAME%", milestone.getMilestoneName()),
                new Replacement("%D%", String.valueOf(TimeUnit.SECONDS.toDays(milestone.getOnlineTime()))),
                new Replacement("%H%", String.valueOf(TimeUnit.SECONDS.toHours(milestone.getOnlineTime()) % 24)),
                new Replacement("%M%", String.valueOf(TimeUnit.SECONDS.toMinutes(milestone.getOnlineTime()) % 60)),
                new Replacement("%S%", String.valueOf(TimeUnit.SECONDS.toSeconds(milestone.getOnlineTime()) % 60))
            ));
            message.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/milestone info " + milestone.getMilestoneName()));
            commandSender.spigot().sendMessage(message);
        }
    }

    @SubCommand(
        subCommand = "info",
        description = "Get info about a milestone",
        usage = "<milestone>",
        permission = "playtime.milestone.info",
        minParams = 2,
        maxParams = 2,
        console = true
    )
    public void info(CommandSender commandSender, List<String> args) {
        Milestone milestone = Milestone.getMilestone(args.get(1));
        if (milestone == null) {
            commandSender.sendMessage(Messages.MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        commandSender.sendMessage("Milestone: " + milestone.getMilestoneName());
        commandSender.sendMessage(" Time: " + milestone.getOnlineTime());
        commandSender.sendMessage(" Rewards("+ milestone.getItemStacks().size() +"): ");
        milestone.getItemStacks().forEach(map -> commandSender.sendMessage("  " + map.toString()));
        commandSender.sendMessage(" Commands("+ milestone.getCommands().size() +"): ");
        milestone.getCommands().forEach(command -> commandSender.sendMessage("  " + command));
        commandSender.sendMessage(" Messages("+ milestone.getMessages().size() +"): ");
        milestone.getMessages().forEach(message -> commandSender.sendMessage("  " + message));
        commandSender.sendMessage(" Firework show: " + milestone.isFireworkShow());
        if (milestone.isFireworkShow()) {
            commandSender.sendMessage(" Firework show delay: " + milestone.getFireworkShowSecondsBetween());
            commandSender.sendMessage(" Firework show amount: " + milestone.getFireworkShowAmount());
        }
    }

    @SubCommand(
        subCommand = "test",
        description = "Execute the rewards of a milestone on yourself",
        usage = "<milestone>",
        permission = "playtime.milestone.test",
        minParams = 2,
        maxParams = 2
    )
    public void test(CommandSender commandSender, List<String> args) {
        Milestone milestone = Milestone.getMilestone(args.get(1));
        if (milestone == null) {
            commandSender.sendMessage(Messages.MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        milestone.apply((Player) commandSender);
        commandSender.sendMessage(Messages.MILESTONE_REWARDS_APPLIED.getMessage());
    }

    @SubCommand(
        subCommand = "addItemToMilestone",
        description = "Add the item in your main hand to the milestone",
        usage = "<milestone>",
        permission = "playtime.milestone.addItemToMilestone",
        minParams = 2,
        maxParams = 2
    )
    public void addItemToMilestone(CommandSender commandSender, List<String> args) {
        Player player = (Player) commandSender;
        Milestone milestone = Milestone.getMilestone(args.get(1));
        if (milestone == null) {
            commandSender.sendMessage(Messages.MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        milestone.addItemStack(player.getInventory().getItemInMainHand());
        Playtime.getInstance().getStorage().updateMilestone(milestone);
        commandSender.sendMessage(Messages.MILESTONE_ITEM_ADDED.getMessage());
        Bukkit.getPluginManager().callEvent(new MilestoneUpdateEvent(milestone));
    }

    @SubCommand(
        subCommand = "addCommand",
        description = "Add a command to the milestone",
        usage = "<milestone> <command>",
        permission = "playtime.milestone.addCommand",
        minParams = 3,
        maxParams = 3,
        console = true
    )
    public void addCommandToMilestone(CommandSender commandSender, List<String> args) {
        Milestone milestone = Milestone.getMilestone(args.get(1));
        if (milestone == null) {
            commandSender.sendMessage(Messages.MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        String command = String.join(" ", args.subList(2, args.size()));
        milestone.addCommand(command);
        Playtime.getInstance().getStorage().updateMilestone(milestone);
        commandSender.sendMessage(Messages.MILESTONE_COMMAND_ADDED.getMessage());
        Bukkit.getPluginManager().callEvent(new MilestoneUpdateEvent(milestone));
    }

    @SubCommand(
        subCommand = "removeCommand",
        description = "Remove a command from the milestone",
        usage = "<milestone> <command>",
        permission = "playtime.milestone.removeCommand",
        minParams = 3,
        maxParams = 3,
        console = true
    )
    public void removeCommandFromMilestone(CommandSender commandSender, List<String> args) {
        Milestone milestone = Milestone.getMilestone(args.get(1));
        if (milestone == null) {
            commandSender.sendMessage(Messages.MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        String command = String.join(" ", args.subList(1, args.size()));
        milestone.removeCommand(command);
        Playtime.getInstance().getStorage().updateMilestone(milestone);
        commandSender.sendMessage(Messages.MILESTONE_COMMAND_REMOVED.getMessage());
        Bukkit.getPluginManager().callEvent(new MilestoneUpdateEvent(milestone));
    }

    @SubCommand(
        subCommand = "togglefirework",
        description = "Toggle the firework for a milestone",
        usage = "<milestone>",
        permission = "playtime.milestone.togglefirework",
        minParams = 2,
        maxParams = 2,
        console = true
    )
    public void toggleFirework(CommandSender commandSender, List<String> args) {
        Milestone milestone = Milestone.getMilestone(args.get(1));
        if (milestone == null) {
            commandSender.sendMessage(Messages.MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        milestone.setFireworkShow(!milestone.isFireworkShow());
        Playtime.getInstance().getStorage().updateMilestone(milestone);
        commandSender.sendMessage(Messages.MILESTONE_FIREWORK_TOGGLED.getMessage(new Replacement("<state>", milestone.isFireworkShow() ? "enabled" : "disabled")));
        Bukkit.getPluginManager().callEvent(new MilestoneUpdateEvent(milestone));
    }

    @SubCommand(
        subCommand = "setfireworkamount",
        description = "Set the amount of firework for a milestone",
        usage = "<milestone> <amount>",
        permission = "playtime.milestone.setfireworkamount",
        minParams = 3,
        maxParams = 3,
        console = true
    )
    public void setFireworkAmount(CommandSender commandSender, List<String> args) {
        Milestone milestone = Milestone.getMilestone(args.get(1));
        if (milestone == null) {
            commandSender.sendMessage(Messages.MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        int amount = Integer.parseInt(args.get(2));
        milestone.setFireworkShowAmount(amount);
        Playtime.getInstance().getStorage().updateMilestone(milestone);
        commandSender.sendMessage(Messages.MILESTONE_SET_FIREWORK_AMOUNT.getMessage(new Replacement("<amount>", String.valueOf(amount))));
        Bukkit.getPluginManager().callEvent(new MilestoneUpdateEvent(milestone));
    }

    @SubCommand(
        subCommand = "setfireworkdelay",
        description = "Set the delay between fireworks for a milestone",
        usage = "<milestone> <time in seconds>",
        permission = "playtime.milestone.setfireworkdelay",
        minParams = 4,
        maxParams = 4,
        console = true
    )
    public void setFireworkDelay(CommandSender commandSender, List<String> args) {
        Milestone milestone = Milestone.getMilestone(args.get(1));
        if (milestone == null) {
            commandSender.sendMessage(Messages.MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        int delay = Integer.parseInt(args.get(2));
        milestone.setFireworkShowSecondsBetween(delay);
        Playtime.getInstance().getStorage().updateMilestone(milestone);
        commandSender.sendMessage(Messages.MILESTONE_SET_FIREWORK_DELAY.getMessage(new Replacement("<amount>", String.valueOf(delay))));
        Bukkit.getPluginManager().callEvent(new MilestoneUpdateEvent(milestone));
    }

    @SubCommand(
        subCommand = "addMessage",
        description = "Add a message to a milestone",
        usage = "<milestone> <message>",
        permission = "playtime.milestone.addMessage",
        minParams = 3,
        maxParams = 3,
        console = true
    )
    public void addMessage(CommandSender commandSender, List<String> args) {
        Milestone milestone = Milestone.getMilestone(args.get(1));
        if (milestone == null) {
            commandSender.sendMessage(Messages.MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        String message = String.join(" ", args.subList(2, args.size()));
        milestone.addMessage(message);
        Playtime.getInstance().getStorage().updateMilestone(milestone);
        commandSender.sendMessage(Messages.MILESTONE_MESSAGE_ADDED.getMessage());
        Bukkit.getPluginManager().callEvent(new MilestoneUpdateEvent(milestone));
    }

    @SubCommand(
        subCommand = "removeMessage",
        description = "Remove a message from a milestone",
        usage = "<milestone> <message>",
        permission = "playtime.milestone.removeMessage",
        minParams = 3,
        maxParams = 3,
        console = true
    )
    public void removeMessage(CommandSender commandSender, List<String> args) {
        Milestone milestone = Milestone.getMilestone(args.get(1));
        if (milestone == null) {
            commandSender.sendMessage(Messages.MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        String message = String.join(" ", args.subList(2, args.size()));
        milestone.removeMessage(message);
        Playtime.getInstance().getStorage().updateMilestone(milestone);
        commandSender.sendMessage(Messages.MILESTONE_MESSAGE_REMOVED.getMessage());
        Bukkit.getPluginManager().callEvent(new MilestoneUpdateEvent(milestone));
    }

    private Map<String, Integer> parseTime(String time) {
        Pattern pattern = Pattern.compile("(\\d+)([A-Za-z]+)");
        Matcher matcher = pattern.matcher(time);
        Map<String, Integer> timeMap = new HashMap<>();

        while (matcher.find()) {
            int value = Integer.parseInt(matcher.group(1));
            String unit = matcher.group(2);
            timeMap.put(unit, value);
        }
        return timeMap;
    }

    private long getTime(String time) {
        AtomicLong parsedTime = new AtomicLong();
        Map<String, Integer> timeMap = parseTime(time);
        timeMap.forEach((unit, value) -> {
            switch (unit.toLowerCase(Locale.ROOT)) {
                case "s":
                case "second":
                case "seconds":
                    parsedTime.addAndGet(TimeUnit.SECONDS.toSeconds(value));
                    break;
                case "m":
                case "minute":
                case "minutes":
                    parsedTime.addAndGet(TimeUnit.MINUTES.toSeconds(value));
                    break;
                case "h":
                case "hour":
                case "hours":
                    parsedTime.addAndGet(TimeUnit.HOURS.toSeconds(value));
                    break;
                case "d":
                case "day":
                case "days":
                    parsedTime.addAndGet(TimeUnit.DAYS.toSeconds(value));
                    break;
                case "w":
                case "week":
                case "weeks":
                    parsedTime.addAndGet(TimeUnit.DAYS.toSeconds(value * 7L));
                    break;
                case "mo":
                case "month":
                case "months":
                    parsedTime.addAndGet(TimeUnit.DAYS.toSeconds(value * 30));
                    break;
                case "y":
                case "year":
                case "years":
                    parsedTime.addAndGet(TimeUnit.DAYS.toSeconds(value * 365L));
                    break;
                default:
                    parsedTime.addAndGet(TimeUnit.SECONDS.toSeconds(value));
            }
        });

        return parsedTime.get();
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/modules/milestones/commands/RepeatingMilestoneCommand.java">
package nl.thedutchruben.playtime.modules.milestones.commands;

import net.md_5.bungee.api.chat.ClickEvent;
import net.md_5.bungee.api.chat.TextComponent;
import nl.thedutchruben.mccore.spigot.commands.Command;
import nl.thedutchruben.mccore.spigot.commands.Default;
import nl.thedutchruben.mccore.spigot.commands.SubCommand;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.events.repeatingmilestone.RepeatingMilestoneCreateEvent;
import nl.thedutchruben.playtime.core.events.repeatingmilestone.RepeatingMilestoneDeleteEvent;
import nl.thedutchruben.playtime.core.events.repeatingmilestone.RepeatingMilestoneUpdateEvent;
import nl.thedutchruben.playtime.core.objects.RepeatingMilestone;
import nl.thedutchruben.playtime.core.translations.Messages;
import nl.thedutchruben.playtime.utils.Replacement;
import org.bukkit.Bukkit;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Command(
        command = "repeatingmilestone",
        description = "Main repeatingmilestone command",
        permission = "playtime.repeatingmilestone",
        console = true)
public class RepeatingMilestoneCommand {

    @SubCommand(
            subCommand = "create",
            description = "Create a new reapeating milestone",
            usage = "<name> <time>",
            permission = "playtime.repeatingmilestone.create",
            console = true,
            minParams = 3,
            maxParams = 3)
    public void create(CommandSender commandSender, List<String> args) {
        RepeatingMilestone repeatingMilestone = new RepeatingMilestone();
        repeatingMilestone.setMilestoneName(args.get(1));
        long time = getTime(args.get(2));
        repeatingMilestone.setOnlineTime(time);
        Playtime.getInstance().getStorage().saveRepeatingMilestone(repeatingMilestone).thenAcceptAsync(aBoolean -> {
            if (aBoolean) {
                commandSender.sendMessage(Messages.REPEATING_MILESTONE_CREATED.getMessage());
                Bukkit.getPluginManager().callEvent(new RepeatingMilestoneCreateEvent(repeatingMilestone));
            } else {
                commandSender.sendMessage(Messages.REPEATING_MILESTONE_COULD_NOT_BE_CREATED.getMessage());
            }
        });
    }

    @SubCommand(
            subCommand = "delete",
            description = "Delete a repeating milestone",
            usage = "<repeatingMilestone>",
            permission = "playtime.repeatingmilestone.delete",
            minParams = 2,
            maxParams = 2,
            console = true
    )
    public void delete(CommandSender commandSender, List<String> args) {
        RepeatingMilestone milestone = RepeatingMilestone.get(args.get(1));
        if (milestone == null) {
            commandSender.sendMessage(Messages.REPEATING_MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        Playtime.getInstance().getStorage().deleteRepeatingMilestone(milestone).thenAcceptAsync(aBoolean -> {
            if (aBoolean) {
                commandSender.sendMessage(Messages.REPEATING_MILESTONE_DELETED.getMessage());
                Bukkit.getPluginManager().callEvent(new RepeatingMilestoneDeleteEvent(milestone));
            } else {
                commandSender.sendMessage(Messages.REPEATING_MILESTONE_DOES_NOT_EXIST.getMessage());
            }
        });
    }

    @Default
    @SubCommand(
        subCommand = "list",
        description = "List all milestones",
        permission = "playtime.repeatingmilestone.list",
        console = true
    )
    public void list(CommandSender commandSender, List<String> args) {
        List<RepeatingMilestone> repeatingMilestones = Playtime.getInstance().getRepeatingMilestones();
        commandSender.sendMessage("Repeating milestones: ");
        for (RepeatingMilestone milestone : repeatingMilestones) {
            TextComponent message = new TextComponent(Messages.REPEATING_MILESTONE_LIST.getMessage(
                    new Replacement("%REPEATING_MILESTONE_NAME%", milestone.getMilestoneName()),
                    new Replacement("%D%", String.valueOf(TimeUnit.SECONDS.toDays(milestone.getOnlineTime()))),
                    new Replacement("%H%", String.valueOf(TimeUnit.SECONDS.toHours(milestone.getOnlineTime()) % 24)),
                    new Replacement("%M%", String.valueOf(TimeUnit.SECONDS.toMinutes(milestone.getOnlineTime()) % 60)),
                    new Replacement("%S%", String.valueOf(TimeUnit.SECONDS.toSeconds(milestone.getOnlineTime()) % 60))
            ));
            message.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/repeatingmilestone info " + milestone.getMilestoneName()));
            commandSender.spigot().sendMessage(message);
        }
    }

    @SubCommand(
        subCommand = "info",
        description = "Get info about a milestone",
        usage = "<repeatingMilestone>",
        permission = "playtime.repeatingmilestone.info",
        minParams = 2,
        maxParams = 2,
        console = true
    )
    public void info(CommandSender commandSender, List<String> args) {
        RepeatingMilestone repeatingMilestone = RepeatingMilestone.get(args.get(1));
        if (repeatingMilestone == null) {
            commandSender.sendMessage(Messages.REPEATING_MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        commandSender.sendMessage("Repeating milestone: " + repeatingMilestone.getMilestoneName());
        commandSender.sendMessage(" Time: " + repeatingMilestone.getOnlineTime());
        commandSender.sendMessage(" Rewards("+ repeatingMilestone.getItemStacks().size() +"): ");
        repeatingMilestone.getItemStacks().forEach(map -> commandSender.sendMessage("  " + map.toString()));
        commandSender.sendMessage(" Commands("+ repeatingMilestone.getCommands().size() +"): ");
        repeatingMilestone.getCommands().forEach(command -> commandSender.sendMessage("  " + command));
        commandSender.sendMessage(" Messages("+ repeatingMilestone.getMessages().size() +"): ");
        repeatingMilestone.getMessages().forEach(message -> commandSender.sendMessage("  " + message));
        commandSender.sendMessage(" Firework show: " + repeatingMilestone.isFireworkShow());
        if (repeatingMilestone.isFireworkShow()) {
            commandSender.sendMessage(" Firework show delay: " + repeatingMilestone.getFireworkShowSecondsBetween());
            commandSender.sendMessage(" Firework show amount: " + repeatingMilestone.getFireworkShowAmount());
        }
    }

    @SubCommand(
        subCommand = "test",
        description = "Execute the rewards of a repeatingmilestone on yourself",
        usage = "<repeatingMilestone>",
        permission = "playtime.repeatingmilestone.test",
        minParams = 2,
        maxParams = 2
    )
    public void test(CommandSender commandSender, List<String> args) {
        RepeatingMilestone repeatingMilestone = RepeatingMilestone.get(args.get(1));
        if (repeatingMilestone == null) {
            commandSender.sendMessage(Messages.REPEATING_MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        repeatingMilestone.apply((Player) commandSender);
        commandSender.sendMessage(Messages.MILESTONE_REWARDS_APPLIED.getMessage());
    }

    @SubCommand(
        subCommand = "addItemToMilestone",
        description = "Add the item in your main hand to the milestone",
        usage = "<repeatingMilestone>",
        permission = "playtime.repeatingmilestone.addItemToMilestone",
        minParams = 2,
        maxParams = 2
    )
    public void addItemToMilestone(CommandSender commandSender, List<String> args) {
        Player player = (Player) commandSender;
        RepeatingMilestone repeatingMilestone = RepeatingMilestone.get(args.get(1));

        if (repeatingMilestone == null) {
            commandSender.sendMessage(Messages.REPEATING_MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }

        repeatingMilestone.addItemStack(player.getInventory().getItemInMainHand());
        Playtime.getInstance().getStorage().updateRepeatingMilestone(repeatingMilestone);
        commandSender.sendMessage(Messages.REPEATING_MILESTONE_ITEM_ADDED.getMessage());
        Bukkit.getPluginManager().callEvent(new RepeatingMilestoneUpdateEvent(repeatingMilestone));
    }

    @SubCommand(
        subCommand = "addCommand",
        description = "Add a command to the milestone",
        usage = "<repeatingMilestone> <command>",
        permission = "playtime.repeatingmilestone.addCommand",
        minParams = 3,
        maxParams = 3,
        console = true
    )
    public void addCommandToMilestone(CommandSender commandSender, List<String> args) {
        RepeatingMilestone repeatingMilestone = RepeatingMilestone.get(args.get(1));

        if (repeatingMilestone == null) {
            commandSender.sendMessage(Messages.REPEATING_MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }

        String command = String.join(" ", args.subList(2, args.size()));
        repeatingMilestone.addCommand(command);
        Playtime.getInstance().getStorage().updateRepeatingMilestone(repeatingMilestone);
        commandSender.sendMessage(Messages.REPEATING_MILESTONE_COMMAND_ADDED.getMessage());
        Bukkit.getPluginManager().callEvent(new RepeatingMilestoneUpdateEvent(repeatingMilestone));
    }

    @SubCommand(
        subCommand = "removeCommand",
        description = "Remove a command from the milestone",
        usage = "<repeatingMilestone> <command>",
        permission = "playtime.repeatingmilestone.removeCommand",
        minParams = 3,
        maxParams = 3,
        console = true
    )
    public void removeCommandFromMilestone(CommandSender commandSender, List<String> args) {
        RepeatingMilestone repeatingMilestone = RepeatingMilestone.get(args.get(1));

        if (repeatingMilestone == null) {
            commandSender.sendMessage(Messages.REPEATING_MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }

        String command = String.join(" ", args.subList(2, args.size()));
        repeatingMilestone.removeCommand(command);
        Playtime.getInstance().getStorage().updateRepeatingMilestone(repeatingMilestone);
        commandSender.sendMessage(Messages.REPEATING_MILESTONE_ITEM_REMOVED.getMessage());
        Bukkit.getPluginManager().callEvent(new RepeatingMilestoneUpdateEvent(repeatingMilestone));
    }

    @SubCommand(
        subCommand = "togglefirework",
        description = "Toggle the firework for a milestone",
        usage = "<repeatingMilestone>",
        permission = "playtime.repeatingmilestone.togglefirework",
        minParams = 2,
        maxParams = 2,
        console = true
    )
    public void toggleFirework(CommandSender commandSender, List<String> args) {
        RepeatingMilestone repeatingMilestone = RepeatingMilestone.get(args.get(1));

        if (repeatingMilestone == null) {
            commandSender.sendMessage(Messages.REPEATING_MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }

        repeatingMilestone.setFireworkShow(!repeatingMilestone.isFireworkShow());
        Playtime.getInstance().getStorage().updateRepeatingMilestone(repeatingMilestone);
        commandSender.sendMessage(Messages.REPEATING_MILESTONE_FIREWORK_TOGGLED.getMessage(new Replacement("<state>", repeatingMilestone.isFireworkShow() ? "enabled" : "disabled")));
        Bukkit.getPluginManager().callEvent(new RepeatingMilestoneUpdateEvent(repeatingMilestone));
    }

    @SubCommand(
        subCommand = "setfireworkamount",
        description = "Set the amount of firework for a milestone",
        usage = "<repeatingMilestone> <amount>",
        permission = "playtime.repeatingmilestone.setfireworkamount",
        minParams = 3,
        maxParams = 3,
        console = true
    )
    public void setFireworkAmount(CommandSender commandSender, List<String> args) {
        RepeatingMilestone repeatingMilestone = RepeatingMilestone.get(args.get(1));

        if (repeatingMilestone == null) {
            commandSender.sendMessage(Messages.REPEATING_MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }

        int amount = Integer.parseInt(args.get(2));
        repeatingMilestone.setFireworkShowAmount(amount);
        Playtime.getInstance().getStorage().updateRepeatingMilestone(repeatingMilestone);
        commandSender.sendMessage(Messages.REPEATING_MILESTONE_SET_FIREWORK_AMOUNT.getMessage(new Replacement("<amount>", String.valueOf(amount))));
        Bukkit.getPluginManager().callEvent(new RepeatingMilestoneUpdateEvent(repeatingMilestone));
    }

    @SubCommand(
        subCommand = "setfireworkdelay",
        description = "Set the delay between fireworks for a milestone",
        usage = "<repeatingMilestone> <time in seconds>",
        permission = "playtime.repeatingmilestone.setfireworkdelay",
        minParams = 4,
        maxParams = 4,
        console = true
    )
    public void setFireworkDelay(CommandSender commandSender, List<String> args) {
        RepeatingMilestone repeatingMilestone = RepeatingMilestone.get(args.get(1));
        if (repeatingMilestone == null) {
            commandSender.sendMessage(Messages.REPEATING_MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        int delay = Integer.parseInt(args.get(2));
        repeatingMilestone.setFireworkShowSecondsBetween(delay);
        Playtime.getInstance().getStorage().updateRepeatingMilestone(repeatingMilestone);
        commandSender.sendMessage(Messages.REPEATING_MILESTONE_SET_FIREWORK_DELAY.getMessage(new Replacement("<amount>", String.valueOf(delay))));
        Bukkit.getPluginManager().callEvent(new RepeatingMilestoneUpdateEvent(repeatingMilestone));
    }

    @SubCommand(
        subCommand = "addMessage",
        description = "Add a message to a milestone",
        usage = "<repeatingMilestone> <message>",
        permission = "playtime.repeatingmilestone.addMessage",
        minParams = 3,
        maxParams = 3,
        console = true
    )
    public void addMessage(CommandSender commandSender, List<String> args) {
        RepeatingMilestone repeatingMilestone = RepeatingMilestone.get(args.get(1));
        if (repeatingMilestone == null) {
            commandSender.sendMessage(Messages.REPEATING_MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        String message = String.join(" ", args.subList(2, args.size()));
        repeatingMilestone.addMessage(message);
        Playtime.getInstance().getStorage().updateRepeatingMilestone(repeatingMilestone);
        commandSender.sendMessage(Messages.REPEATING_MILESTONE_MESSAGE_ADDED.getMessage());
        Bukkit.getPluginManager().callEvent(new RepeatingMilestoneUpdateEvent(repeatingMilestone));
    }

    @SubCommand(
        subCommand = "removeMessage",
        description = "Remove a message from a milestone",
        usage = "<repeatingMilestone> <message>",
        permission = "playtime.repeatingmilestone.removeMessage",
        minParams = 3,
        maxParams = 3,
        console = true
    )
    public void removeMessage(CommandSender commandSender, List<String> args) {
        RepeatingMilestone repeatingMilestone = RepeatingMilestone.get(args.get(1));
        if (repeatingMilestone == null) {
            commandSender.sendMessage(Messages.REPEATING_MILESTONE_DOES_NOT_EXIST.getMessage());
            return;
        }
        String message = String.join(" ", args.subList(2, args.size()));
        repeatingMilestone.removeMessage(message);
        Playtime.getInstance().getStorage().updateRepeatingMilestone(repeatingMilestone);
        commandSender.sendMessage(Messages.REPEATING_MILESTONE_MESSAGE_REMOVED.getMessage());
        Bukkit.getPluginManager().callEvent(new RepeatingMilestoneUpdateEvent(repeatingMilestone));
    }

    private Map<String, Integer> parseTime(String time) {
        Pattern pattern = Pattern.compile("(\\d+)([A-Za-z]+)");
        Matcher matcher = pattern.matcher(time);
        Map<String, Integer> timeMap = new HashMap<>();

        while (matcher.find()) {
            int value = Integer.parseInt(matcher.group(1));
            String unit = matcher.group(2);
            timeMap.put(unit, value);
        }
        return timeMap;
    }

    private long getTime(String time) {
        AtomicLong parsedTime = new AtomicLong();
        Map<String, Integer> timeMap = parseTime(time);
        timeMap.forEach((unit, value) -> {
            switch (unit.toLowerCase(Locale.ROOT)) {
                case "s":
                case "second":
                case "seconds":
                    parsedTime.addAndGet(TimeUnit.SECONDS.toSeconds(value));
                    break;
                case "m":
                case "minute":
                case "minutes":
                    parsedTime.addAndGet(TimeUnit.MINUTES.toSeconds(value));
                    break;
                case "h":
                case "hour":
                case "hours":
                    parsedTime.addAndGet(TimeUnit.HOURS.toSeconds(value));
                    break;
                case "d":
                case "day":
                case "days":
                    parsedTime.addAndGet(TimeUnit.DAYS.toSeconds(value));
                    break;
                case "w":
                case "week":
                case "weeks":
                    parsedTime.addAndGet(TimeUnit.DAYS.toSeconds(value * 7L));
                    break;
                case "mo":
                case "month":
                case "months":
                    parsedTime.addAndGet(TimeUnit.DAYS.toSeconds(value * 30));
                    break;
                case "y":
                case "year":
                case "years":
                    parsedTime.addAndGet(TimeUnit.DAYS.toSeconds(value * 365L));
                    break;
                default:
                    parsedTime.addAndGet(TimeUnit.SECONDS.toSeconds(value));
            }
        });

        return parsedTime.get();
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/modules/milestones/listeners/UpdatePlaytimeListener.java">
package nl.thedutchruben.playtime.modules.milestones.listeners;

import nl.thedutchruben.mccore.spigot.listeners.TDRListener;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.events.player.AsyncPlaytimePlayerUpdatePlaytimeEvent;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;

import java.util.logging.Level;

/**
 * Listener class that handles the update of player playtime milestones.
 */
@TDRListener
public class UpdatePlaytimeListener implements Listener {

    /**
     * Event handler for updating player playtime.
     *
     * @param event The event that contains the old and new playtime of the player.
     */
    @EventHandler
    public void updatePlaytime(AsyncPlaytimePlayerUpdatePlaytimeEvent event) {
        // todo move to debug message
//        Playtime.getPlugin().getLogger().log(Level.INFO, "Updating playtime for player " + event.getUser().getBukkitPlayer().getName() + " from " + event.getOldPlaytime() + " to " + event.getNewPlaytime());
        Playtime.getInstance().getMilestones().forEach(milestone -> Playtime.getPlugin().getLogger().log(Level.INFO, "Milestone: " + milestone.getOnlineTimeInMilliseconds()));
        // Check and apply milestones that are not repeating
        Playtime.getInstance().getMilestones().stream()
                .filter(milestone -> milestone.getOnlineTimeInMilliseconds() <= event.getNewPlaytime()
                        && milestone.getOnlineTimeInMilliseconds() > event.getOldPlaytime())
                .forEach(milestone -> milestone.apply(event.getUser().getBukkitPlayer()));

        // Check and apply repeating milestones
        for (float i = event.getOldPlaytime(); i < event.getNewPlaytime(); i++) {
            if (i > 0) {
                float finalI = i;
                Playtime.getInstance().getRepeatingMilestones().stream()
                        .filter(repeatingMilestone -> finalI % (repeatingMilestone.getOnlineTimeInMilliseconds() * 1000) == 1)
                        .forEach(repeatingMilestone -> repeatingMilestone.apply(event.getUser().getBukkitPlayer()));
            }
        }
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/modules/player/commands/PlayTimeCommand.java">
package nl.thedutchruben.playtime.modules.player.commands;

import nl.thedutchruben.mccore.spigot.commands.Command;
import nl.thedutchruben.mccore.spigot.commands.Default;
import nl.thedutchruben.mccore.spigot.commands.Fallback;
import nl.thedutchruben.mccore.spigot.commands.SubCommand;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import nl.thedutchruben.playtime.core.translations.Messages;
import nl.thedutchruben.playtime.utils.Replacement;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Command(command = "playtime", description = "Main playtime command", permission = "playtime.playtime", console = true)
public class PlayTimeCommand {

    @Default
    @SubCommand(subCommand = "", description = "Show your own playtime")
    public void myTime(CommandSender sender, List<String> args) {
        if (sender instanceof Player) {
            PlaytimeUser user = Playtime.getInstance().getPlaytimeUsers().get(((Player) sender).getUniqueId());
            user.updatePlaytime();
            sender.sendMessage(Messages.PLAYTIME_INFO_OWN.getMessage(
                    new Replacement("%D%", String.valueOf(user.translateTime()[0])),
                    new Replacement("%H%", String.valueOf(user.translateTime()[1])),
                    new Replacement("%M%", String.valueOf(user.translateTime()[2])),
                    new Replacement("%S%", String.valueOf(user.translateTime()[3]))
            ));
        } else {
            sender.sendMessage("You need to be a player to use this command");
        }
    }

    @Fallback(minParams = 1, maxParams = 2)
    @SubCommand(subCommand = "", minParams = 1, maxParams = 2, usage = "<player>", description = "Show a player's playtime")
    public void see(CommandSender sender, List<String> args) {
        String playerName = args.get(0);
        Player player = Bukkit.getPlayer(playerName);

        if (player == null) {
            Playtime.getInstance().getStorage().loadUserByName(playerName).thenAcceptAsync(user -> {
                if (user == null) {
                    sender.sendMessage(Messages.PLAYER_DOES_NOT_EXIST.getMessage());
                } else {
                    sendPlaytimeInfo(sender, user);
                }
            });
        } else {
            Playtime.getInstance().getPlaytimeUser(playerName).ifPresent(user -> sendPlaytimeInfo(sender, user));
        }
    }

    @SubCommand(subCommand = "top", minParams = 0, maxParams = 1, usage = "<amount>", permission = "playtime.playtime.top", console = true, description = "Show the top 10 players")
    public void top(CommandSender sender, List<String> args) {
        int amount = 10;
        if (args.size() == 2) {
            amount = Integer.parseInt(args.get(1));
        }
        Playtime.getInstance().getStorage().getTopUsers(amount, 0).whenCompleteAsync((users, throwable) -> {
            users.forEach(user -> sendPlaytimeInfo(sender, user));
        });
    }

    @SubCommand(subCommand = "reset", permission = "playtime.playtime.reset", minParams = 2, maxParams = 2, console = true, usage = "<player>", description = "Reset a player's playtime")
    public void reset(CommandSender sender, List<String> args) {
        String playerName = args.get(1);
        Playtime.getInstance().getStorage().loadUserByName(playerName).thenAcceptAsync(user -> {
            if (user != null) {
                user.setPlaytime(0);
                Playtime.getInstance().getPlaytimeUser(playerName).ifPresent(u -> u.setPlaytime(0));
                Playtime.getInstance().getStorage().saveUser(user).thenAcceptAsync(u -> {
                    sender.sendMessage(Messages.PLAYER_RESET_CONFIRM.getMessage());
                });
            } else {
                sender.sendMessage(Messages.PLAYER_DOES_NOT_EXIST.getMessage());
            }
        });
    }

    @SubCommand(subCommand = "add", permission = "playtime.playtime.add", minParams = 3, maxParams = 3, console = true, description = "Add playtime to a user", usage = "<player> <time>")
    public void add(CommandSender sender, List<String> args) {
        String playerName = args.get(1);
        String time = args.get(2);
        Map<String, Integer> timeMap = parseTime(time);

        Playtime.getInstance().getPlaytimeUser(playerName).ifPresentOrElse(user -> {
            addPlaytime(user, timeMap, time);
            user.save().thenAcceptAsync(test -> {
                sender.sendMessage(Messages.TIME_ADDED.getMessage(new Replacement("<player>", playerName), new Replacement("%playtime%", playerName)));
            });
        }, () -> {
            Playtime.getInstance().getStorage().loadUserByName(playerName).thenAcceptAsync(user -> {
                addPlaytime(user, timeMap, time);
                user.save().thenAcceptAsync(test -> {
                    sender.sendMessage(Messages.TIME_ADDED.getMessage(new Replacement("<player>", playerName), new Replacement("%playtime%", playerName)));
                });
            });
        });
    }

    @SubCommand(subCommand = "remove", permission = "playtime.playtime.remove", minParams = 3, maxParams = 3, console = true, usage = "<player> <time>", description = "Remove playtime from a user")
    public void remove(CommandSender sender, List<String> args) {
        String playerName = args.get(1);
        String time = args.get(2);
        Map<String, Integer> timeMap = parseTime(time);

        Playtime.getInstance().getPlaytimeUser(playerName).ifPresentOrElse(user -> {
            removePlaytime(user, timeMap, time);
            user.save().thenAcceptAsync(test -> {
                sender.sendMessage(Messages.TIME_REMOVED.getMessage(new Replacement("<player>", playerName), new Replacement("%playtime%", playerName)));
            });
        }, () -> {
            Playtime.getInstance().getStorage().loadUserByName(playerName).thenAcceptAsync(user -> {
                removePlaytime(user, timeMap, time);
                user.save().thenAcceptAsync(test -> {
                    sender.sendMessage(Messages.TIME_REMOVED.getMessage(new Replacement("<player>", playerName), new Replacement("%playtime%", playerName)));
                });
            });
        });
    }

    @SubCommand(subCommand = "pluginInfo", permission = "playtime.playtime.pluginInfo", console = true, description = "Show info about the plugin", minParams = 1)
    public void pluginInfo(CommandSender sender, List<String> args) {
        sender.sendMessage(ChatColor.GREEN + "Playtime by TheDutchRuben");
        sender.sendMessage(ChatColor.GREEN + "Version: " + ChatColor.DARK_GRAY + Playtime.getPlugin().getDescription().getVersion());
        sender.sendMessage(ChatColor.GREEN + "Author: " + ChatColor.DARK_GRAY + Playtime.getPlugin().getDescription().getAuthors());
        sender.sendMessage(ChatColor.GREEN + "Website: " + ChatColor.DARK_GRAY + Playtime.getPlugin().getDescription().getWebsite());
        Playtime.getInstance().getStorage().getMilestones().whenComplete((milestones, throwable) -> {
            sender.sendMessage(ChatColor.GREEN + "Milestones: " + ChatColor.DARK_GRAY + milestones.size());
        });
        Playtime.getInstance().getStorage().getRepeatingMilestones().whenComplete((milestones, throwable) -> {
            sender.sendMessage(ChatColor.GREEN + "Repeating Milestones: " + ChatColor.DARK_GRAY + milestones.size());
        });
        Playtime.getInstance().getMccore().getUpdate(sender, true);
    }

    private void sendPlaytimeInfo(CommandSender sender, PlaytimeUser user) {
        sender.sendMessage(Messages.PLAYTIME_INFO_OTHER.getMessage(
                new Replacement("%NAME%", user.getName()),
                new Replacement("%D%", String.valueOf(user.translateTime()[0])),
                new Replacement("%H%", String.valueOf(user.translateTime()[1])),
                new Replacement("%M%", String.valueOf(user.translateTime()[2])),
                new Replacement("%S%", String.valueOf(user.translateTime()[3]))
        ));
    }

    /**
     * Parse the time string
     * @param time The time string
     * @return The map of time units
     */
    private Map<String, Integer> parseTime(String time) {
        Pattern pattern = Pattern.compile("(\\d+)([A-Za-z]+)");
        // Parse the time string
        // Example: 1d2h3m4s
        Matcher matcher = pattern.matcher(time);
        Map<String, Integer> timeMap = new HashMap<>();

        while (matcher.find()) {
            int value = Integer.parseInt(matcher.group(1));
            String unit = matcher.group(2);
            timeMap.put(unit, value);
        }

        return timeMap;
    }

    /**
     * Add playtime to a user
     * @param user The user to add playtime to
     * @param timeMap The map of time units
     * @param time The time to add
     */
    private void addPlaytime(PlaytimeUser user, Map<String, Integer> timeMap, String time) {
        if (timeMap.isEmpty()) {
            user.addPlaytime(Long.parseLong(time), TimeUnit.SECONDS);
        } else {
            timeMap.forEach((unit, value) -> {
                switch (unit.toUpperCase(Locale.ROOT)) {
                    case "S":
                        user.addPlaytime(value, TimeUnit.SECONDS);
                        break;
                    case "M":
                        user.addPlaytime(value, TimeUnit.MINUTES);
                        break;
                    case "H":
                        user.addPlaytime(value, TimeUnit.HOURS);
                        break;
                    case "D":
                        user.addPlaytime(value, TimeUnit.DAYS);
                        break;
                    case "W":
                        user.addPlaytime(value * 7L, TimeUnit.DAYS);
                        break;
                }
            });
        }
    }

    /**
     * Remove playtime from a user
     * @param user The user to remove playtime from
     * @param timeMap The map of time units
     * @param time The time to remove
     */
    private void removePlaytime(PlaytimeUser user, Map<String, Integer> timeMap, String time) {
        if (timeMap.isEmpty()) {
            user.removePlaytime(Long.parseLong(time), TimeUnit.SECONDS);
        } else {
            timeMap.forEach((unit, value) -> {
                switch (unit.toUpperCase(Locale.ROOT)) {
                    case "S":
                        user.removePlaytime(value, TimeUnit.SECONDS);
                        break;
                    case "M":
                        user.removePlaytime(value, TimeUnit.MINUTES);
                        break;
                    case "H":
                        user.removePlaytime(value, TimeUnit.HOURS);
                        break;
                    case "D":
                        user.removePlaytime(value, TimeUnit.DAYS);
                        break;
                    case "W":
                        user.removePlaytime(value * 7L, TimeUnit.DAYS);
                        break;
                }
            });
        }
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/modules/player/listeners/PlayerJoinListener.java">
package nl.thedutchruben.playtime.modules.player.listeners;

import nl.thedutchruben.mccore.spigot.listeners.TDRListener;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.events.player.PlaytimePlayerLoadedEvent;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import org.bukkit.Bukkit;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;

@TDRListener
public class PlayerJoinListener implements Listener {

    @EventHandler
    public void onJoin(PlayerJoinEvent event) {
        Playtime.getInstance().getStorage().loadUser(event.getPlayer().getUniqueId()).thenAcceptAsync(playtimeUser -> {

            if (playtimeUser != null) {
                Playtime.getInstance().getPlaytimeUsers().put(event.getPlayer().getUniqueId(), playtimeUser);
            } else {
                PlaytimeUser playtimeUser1 = new PlaytimeUser(event.getPlayer().getUniqueId().toString(), event.getPlayer().getName());
                Playtime.getInstance().getStorage().createUser(playtimeUser1);
                Playtime.getInstance().getPlaytimeUsers().put(event.getPlayer().getUniqueId(), playtimeUser1);
            }

            Bukkit.getPluginManager().callEvent(new PlaytimePlayerLoadedEvent(Playtime.getInstance().getPlaytimeUsers().get(event.getPlayer().getUniqueId()), true));
        });
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/modules/player/listeners/PlayerQuitListener.java">
package nl.thedutchruben.playtime.modules.player.listeners;

import com.google.gson.Gson;
import nl.thedutchruben.mccore.spigot.listeners.TDRListener;
import nl.thedutchruben.mccore.utils.config.FileManager;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.events.player.PlaytimePlayerSaveEvent;
import nl.thedutchruben.playtime.core.events.player.PlaytimePlayerUnLoadedEvent;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import org.bukkit.Bukkit;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerQuitEvent;

@TDRListener
public class PlayerQuitListener implements Listener {

    @EventHandler
    public void onQuit(PlayerQuitEvent event) {
        Bukkit.getPluginManager().callEvent(new PlaytimePlayerSaveEvent(Playtime.getInstance().getPlaytimeUsers().get(event.getPlayer().getUniqueId()), false));

        Bukkit.getScheduler().runTaskAsynchronously(Playtime.getPlugin(), () -> {
            PlaytimeUser user = Playtime.getInstance().getPlaytimeUsers().get(event.getPlayer().getUniqueId());

            user.updatePlaytime();

            Playtime.getInstance().getStorage().saveUser(Playtime.getInstance().getPlaytimeUsers().get(event.getPlayer().getUniqueId())).thenAcceptAsync(aBoolean -> {

                if (aBoolean) {
                    Bukkit.getPluginManager().callEvent(new PlaytimePlayerUnLoadedEvent(Playtime.getInstance().getPlaytimeUsers().get(event.getPlayer().getUniqueId()), true));
                    Playtime.getInstance().getPlaytimeUsers().remove(event.getPlayer().getUniqueId());
                } else {
                    Playtime.getPlugin().getLogger().warning("Could not save the user " + event.getPlayer().getName() + " to the storage");
                    FileManager.Config config = Playtime.getInstance().getFileManager().getConfig("recover/" + event.getPlayer().getUniqueId() + ".yml");
                    config.set("data", new Gson().toJson(user));
                    config.save();
                }

            });
        });
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/modules/player/runnables/SavePlayTimeRunnable.java">
package nl.thedutchruben.playtime.modules.player.runnables;

import nl.thedutchruben.mccore.spigot.runnables.ASyncRepeatingTask;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;

import java.util.logging.Level;

/**
 * Save the playtime of the players every 5 minutes
 */
@ASyncRepeatingTask(repeatTime = 6000, startTime = 6000)
public class SavePlayTimeRunnable implements Runnable {

    /**
     * When an object implementing interface {@code Runnable} is used
     * to create a thread, starting the thread causes the object's
     * {@code run} method to be called in that separately executing
     * thread.
     * <p>
     * The general contract of the method {@code run} is that it may
     * take any action whatsoever.
     *
     * @see Thread#run()
     */
    @Override
    public void run() {
        if (Playtime.getInstance().getPlaytimeUsers().isEmpty()) return;
        Playtime.getPlugin().getLogger().log(Level.INFO, "Saving playtime...");
        for (PlaytimeUser value : Playtime.getInstance().getPlaytimeUsers().values()) {
            Playtime.getInstance().getStorage().saveUser(value);
        }
        Playtime.getPlugin().getLogger().log(Level.INFO, "Saved playtime of {0} players", Playtime.getInstance().getPlaytimeUsers().size());
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/modules/player/runnables/UpdatePlayTimeRunnable.java">
package nl.thedutchruben.playtime.modules.player.runnables;

import nl.thedutchruben.mccore.spigot.runnables.ASyncRepeatingTask;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;

/**
 * Every 15 seconds the playtime will update for scoreboards and for getting the milestones
 */
@ASyncRepeatingTask(repeatTime = 300, startTime = 300)
public class UpdatePlayTimeRunnable implements Runnable {

    /**
     * When an object implementing interface {@code Runnable} is used
     * to create a thread, starting the thread causes the object's
     * {@code run} method to be called in that separately executing
     * thread.
     * <p>
     * The general contract of the method {@code run} is that it may
     * take any action whatsoever.
     *
     * @see Thread#run()
     */
    @Override
    public void run() {
        for (PlaytimeUser playtimeUser : Playtime.getInstance().getPlaytimeUsers().values()) {
            playtimeUser.updatePlaytime();
        }
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/modules/playtime_history/commands/PlaytimeHistoryCommand.java">
package nl.thedutchruben.playtime.modules.playtime_history.commands;

public class PlaytimeHistoryCommand {

}
</file>

<file path="main/java/nl/thedutchruben/playtime/modules/playtime_history/listeners/PlayTimePlayerLoadedListener.java">
package nl.thedutchruben.playtime.modules.playtime_history.listeners;

import nl.thedutchruben.mccore.spigot.listeners.TDRListener;
import nl.thedutchruben.playtime.Playtime;
import nl.thedutchruben.playtime.core.events.player.PlaytimePlayerLoadedEvent;
import nl.thedutchruben.playtime.core.events.player.PlaytimePlayerUnLoadedEvent;
import nl.thedutchruben.playtime.core.storage.Storage;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;

@TDRListener
public class PlayTimePlayerLoadedListener implements Listener {

    @EventHandler
    public void onJoin(PlaytimePlayerLoadedEvent event) {
        Playtime.getInstance().getStorage().addPlaytimeHistory(event.getUser().getUUID(), Storage.Event.JOIN, (int) event.getUser().getTime());
    }

    @EventHandler
    public void onQuit(PlaytimePlayerUnLoadedEvent event) {
        Playtime.getInstance().getStorage().addPlaytimeHistory(event.getUser().getUUID(), Storage.Event.QUIT, (int) event.getUser().getTime());
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/modules/playtime_history/runnables/MidnightSaveJoinsRunnable.java">
package nl.thedutchruben.playtime.modules.playtime_history.runnables;


public class MidnightSaveJoinsRunnable {
}
</file>

<file path="main/java/nl/thedutchruben/playtime/modules/playtime_history/runnables/MidnightSaveQuitsRunnable.java">
package nl.thedutchruben.playtime.modules.playtime_history.runnables;

public class MidnightSaveQuitsRunnable {
}
</file>

<file path="main/java/nl/thedutchruben/playtime/Playtime.java">
package nl.thedutchruben.playtime;

import lombok.Getter;
import nl.thedutchruben.mccore.Mccore;
import nl.thedutchruben.mccore.config.UpdateCheckerConfig;
import nl.thedutchruben.mccore.spigot.commands.CommandRegistry;
import nl.thedutchruben.mccore.utils.config.FileManager;
import nl.thedutchruben.playtime.core.Settings;
import nl.thedutchruben.playtime.core.objects.Milestone;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import nl.thedutchruben.playtime.core.objects.RepeatingMilestone;
import nl.thedutchruben.playtime.core.storage.Storage;
import nl.thedutchruben.playtime.core.storage.exceptions.StorageTypeNotFoundException;
import nl.thedutchruben.playtime.core.storage.types.Mongodb;
import nl.thedutchruben.playtime.core.storage.types.Mysql;
import nl.thedutchruben.playtime.core.storage.types.SqlLite;
import nl.thedutchruben.playtime.core.storage.types.Yaml;
import nl.thedutchruben.playtime.core.translations.Messages;
import nl.thedutchruben.playtime.extentions.BStatsExtension;
import nl.thedutchruben.playtime.extentions.PlaceholderAPIExtension;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.plugin.java.JavaPlugin;

import java.util.*;
import java.util.logging.Level;
import java.util.stream.Collectors;

/**
 * Tdrplaytime is the playtime plugin you need to track the time of your players
 * and reward them for beeing online
 */
public class Playtime {

    /**
     * Instance of playtime
     */
    @Getter
    private static Playtime instance;

    /**
     * Instance of the JavaPlugin
     */
    @Getter
    private static JavaPlugin plugin;
    /**
     * Cache of the PlaytimeUsers
     */
    @Getter
    public Map<UUID, PlaytimeUser> playtimeUsers = new HashMap<>();
    /**
     * The selected storage method
     */
    @Getter
    public Storage storage;
    /**
     * Cache of the Milestones
     */
    @Getter
    public List<Milestone> milestones;
    /**
     * Cache of the RepeatingMilestones
     */
    @Getter
    public List<RepeatingMilestone> repeatingMilestones;
    /**
     * Instance of the core
     */
    @Getter
    private Mccore mccore;
    /**
     * Instance of the FileManager
     */
    @Getter
    private FileManager fileManager;

    public Playtime(JavaPlugin playTimePlugin) {
        plugin = playTimePlugin;
    }

    public void onEnable(JavaPlugin playTimePlugin) {
        instance = this;
        this.fileManager = new FileManager(plugin);

        Settings.setupDefaults();
        Messages.setupDefaults();

        //set up the storage
        this.storage = getSelectedStorage();
        this.storage.setup();

        // Register the mc core
        mccore = new Mccore(plugin, "tdrplaytime", "623a25c0ea9f206b0ba31f3f", Mccore.PluginType.SPIGOT);
        if (Settings.UPDATE_CHECK.getValueAsBoolean()) {
            mccore.startUpdateChecker(new UpdateCheckerConfig("tdrplaytime.admin", 60));
        }

        mccore.registerCompleters();
        // Register the bstats
        new BStatsExtension().startBStats(playTimePlugin);

        // Register the placeholder api
        if (Bukkit.getPluginManager().isPluginEnabled("PlaceholderAPI")) {
            new PlaceholderAPIExtension().register();
        }

        // Load the messages
        this.storage.getMilestones().thenAccept(milestones -> this.milestones = milestones).join();
        getPlugin().getLogger().log(Level.INFO, "Loaded {0} milestones", Optional.of(this.milestones.size()));
        this.storage.getRepeatingMilestones().thenAccept(repeatingMilestones -> this.repeatingMilestones = repeatingMilestones).join();
        getPlugin().getLogger().log(Level.INFO, "Loaded {0} repeatingmilestones", Optional.of(this.repeatingMilestones.size()));

        for (Player onlinePlayer : Bukkit.getOnlinePlayers()) {
            UUID playerUUID = onlinePlayer.getUniqueId();
            Playtime.getInstance().getStorage().loadUser(playerUUID).thenAccept(playtimeUser -> {
                if (playtimeUser == null) {
                    playtimeUser = new PlaytimeUser(playerUUID.toString(), onlinePlayer.getName());
                    Playtime.getInstance().getStorage().createUser(playtimeUser);
                }
                Playtime.getInstance().getPlaytimeUsers().put(playerUUID, playtimeUser);
            });
        }

        CommandRegistry.getTabCompletable().put("milestone", commandSender ->
                this.milestones.stream().map(Milestone::getMilestoneName)
                        .collect(Collectors.toSet())
        );

        CommandRegistry.getTabCompletable().put("repeatingMilestone", commandSender ->
                this.repeatingMilestones.stream().map(RepeatingMilestone::getMilestoneName)
                        .collect(Collectors.toSet())
        );
    }

    public Storage getSelectedStorage() {
        String storageType = Settings.STORAGE_TYPE.getValueAsString().toLowerCase();
        switch (storageType) {
            case "mongodb":
            case "mongo":
                return new Mongodb();
            case "mysql":
            case "sql":
            case "mariadb":
                return new Mysql();
            case "yaml":
            case "yml":
                getPlugin().getLogger().log(Level.WARNING, "Yaml storage is not recommended. If you have a lot of players it can cause lag. Please use sqlLite, mysql or mongodb");
                return new Yaml();
            case "sqlite":
            case "sqllite":
                return new SqlLite();
            case "postgresql":
                throw new StorageTypeNotFoundException("Postgresql is not supported yet");
            case "h2":
                throw new StorageTypeNotFoundException("H2 is not supported yet");
            default:
                throw new StorageTypeNotFoundException("Storage type " + storageType + " not found");
        }
    }

    public void onDisable() {

        for (PlaytimeUser playtimeUser : playtimeUsers.values()) {
            storage.saveUser(playtimeUser);
        }

        this.storage.stop();
        this.milestones.clear();
        this.repeatingMilestones.clear();
        Messages.getMessages().clear();
    }

    /**
     * Get the playtime user from the cache or load it from the storage
     *
     * @param uuid The uuid of the player
     * @return The playtime user
     */
    public Optional<PlaytimeUser> getPlaytimeUser(UUID uuid) {
        return Optional.of(playtimeUsers.get(uuid));
    }

    /**
     * Get a playtime user by name
     *
     * @param name The name of the player
     * @return The playtime user if exist
     */
    public Optional<PlaytimeUser> getPlaytimeUser(String name) {
        return playtimeUsers.values().stream().filter(item -> item.getName().equalsIgnoreCase(name)).findFirst();
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/PlayTimePlugin.java">
package nl.thedutchruben.playtime;

import nl.thedutchruben.playtime.core.DependencyLoader;
import org.bukkit.plugin.java.JavaPlugin;

/**
 * The main class of the plugin
 * Tdrplaytime is the playtime plugin for tracking the playtime of players and rewarding them!
 *
 * @version 1.0.0
 * @see JavaPlugin
 * @since 1.0.0
 */
public class PlayTimePlugin extends JavaPlugin {
    private Playtime playtime;

    @Override
    public void onLoad() {
        // Load the dependencies of the plugin
        // the dependencies will load by downloading the jar from the maven repository
        // this will keep the download size of the plugin low
        DependencyLoader.load(this);
    }

    @Override
    public void onEnable() {
        playtime = new Playtime(this);
        playtime.onEnable(this);
    }

    @Override
    public void onDisable() {
        if (playtime != null) {
            playtime.onDisable();
        }
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/PlayTimePluginTest.java">
package nl.thedutchruben.playtime;

import be.seeseemelk.mockbukkit.MockBukkit;
import be.seeseemelk.mockbukkit.ServerMock;
import be.seeseemelk.mockbukkit.entity.PlayerMock;
import nl.thedutchruben.playtime.core.objects.PlaytimeUser;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

public class PlayTimePluginTest {

    private ServerMock server;
    private PlayTimePlugin plugin;

    @BeforeEach
    void setUp() {
        // Start the mock server
        server = MockBukkit.mock();

        // Load the plugin
        plugin = MockBukkit.load(PlayTimePlugin.class);
    }

    @AfterEach
    void tearDown() {
        // Stop the mock server
        MockBukkit.unmock();
    }

    @Test
    void testPluginEnables() {
        assertTrue(plugin.isEnabled());
    }

    @Test
    void testPlayerJoin() {
        // Add a player to the server which should trigger the join event
        PlayerMock player = server.addPlayer();

        // Give the async tasks time to complete
        server.getScheduler().performTicks(100);

        // The player should have been added to Playtime's user map
        PlaytimeUser user = Playtime.getInstance().getPlaytimeUsers().get(player.getUniqueId());
        assertNotNull(user);
        assertEquals(player.getName(), user.getName());
        assertEquals(player.getUniqueId().toString(), user.getUUID().toString());
    }

    @Test
    void testPlaytimeCommand() {
        // Add a player
        PlayerMock player = server.addPlayer();
        server.getScheduler().performTicks(100);

        // Get the player's playtime user and set some playtime
        PlaytimeUser user = Playtime.getInstance().getPlaytimeUsers().get(player.getUniqueId());
        user.addPlaytime(2, TimeUnit.HOURS);

        // Execute the command
        player.performCommand("playtime");

        // Player should receive a message containing their playtime
        player.assertSaid("[PlayTime] Your playtime is 0 day(s) 2 hour(s) 0 minute(s) 0 second(s)");
    }

    @Test
    void testMilestoneCommand() {
        // Add a player with OP permissions
        PlayerMock player = server.addPlayer();
        player.setOp(true);
        server.getScheduler().performTicks(100);

        // Create a milestone
        player.performCommand("milestone create TestMilestone 3600");
        player.assertSaid("The milestone is created!");

        // List milestones
        player.performCommand("milestone list");
        player.assertSaid("TestMilestone Time: Days: 0 Hours: 1 ,Minute's: 0 ,Seconds's: 0");
    }

    @Test
    void testPlaytimeIncreases() {
        // Add a player
        PlayerMock player = server.addPlayer();
        server.getScheduler().performTicks(100);

        // Get the initial playtime
        PlaytimeUser user = Playtime.getInstance().getPlaytimeUsers().get(player.getUniqueId());
        float initialPlaytime = user.getTime();

        // Trigger the update playtime runnable
        server.getScheduler().performTicks(300);

        // Playtime should have increased
        float newPlaytime = user.getTime();
        assertTrue(newPlaytime > initialPlaytime);
    }
}
</file>

<file path="main/java/nl/thedutchruben/playtime/utils/Replacement.java">
package nl.thedutchruben.playtime.utils;

import lombok.Getter;

/**
 * @author Ruben
 * @version 1.0
 * <p>
 * This class is used to replace a string with a string.
 * </p>
 * @since 1.0
 */
@Getter
public class Replacement {
    /**
     * The string to replace.
     * -- GETTER --
     *
     * @return The string to replace.
     */
    private final String from;

    /**
     * The string to replace with.
     * -- GETTER --
     *
     * @return The string to replace with.
     */
    private final String to;

    /**
     * @param from The string to replace.
     * @param to   The string to replace with.
     */
    public Replacement(String from, String to) {
        this.from = from;
        this.to = to;
    }
}
</file>

<file path="main/resources/plugin.yml">
name: TDRPlaytime
version: ${project.version}
main: nl.thedutchruben.playtime.PlayTimePlugin
api-version: 1.13
downloadSource: 'GITHUB'
authors: [ TheDutchRuben ]
softdepend:
  - PlaceholderAPI
  - EssentialsX
description: Playtime plugin with milestone support
commands:
  playtime:
    aliases:
      - playertime
      - onlinetime
    description: Main play time command
    permission: playtime.playtime
  milestone:
    aliases:
      - mstone
      - miliestone
    description: Setup the milestones of the playtime plugin
    permission: playtime.milestone
  repeatingmilestone:
    aliases:
      - rmstone
      - rmiliestone
    description: Setup the repeating milestones of the playtime plugin
    permission: playtime.repeatingmilestone
permissions:
  playtime.playtime:
    default: true
  playtime.playtime.other:
    default: op
  playtime.playtime.reset:
    default: op
  playtime.playtime.top:
    default: op
  playtime.milestone:
    default: op
  playtime.milestone.additem:
    default: op
  playtime.milestone.addcommand:
    default: op
</file>

</files>
